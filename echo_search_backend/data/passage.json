{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1767049141185273857",
        "title": "WebSocket 在 JS 中的使用以及在 SpringBoot 中整合 WebSocket",
        "description": "WebSocket 在 JS 以及 SpringBoot 中的使用",
        "content": "# 前端 WebSocket 的一些使用\n\nWebSocket 是一种网络通信协议，用于实现双向通信。在前端中，你可以使用 JavaScript 中的 `WebSocket` 对象来创建 WebSocket 连接，发送和接收数据。\n\n## 连接的建立\n\n通过创建一个 WebSocket 对象建立一个 WebSocket 连接\n\n例如：\n\n```js\nconst ws = new WebSocket('ws://localhost:8080/channel/echo');\n```\n\n传给对象的参数是通过 WebSocket 协议通讯的网络地址。\n\n## 接收消息\n\n接收消息这里指的是接收服务端的消息。\n\n这里有两种方法。\n\n1. **使用 `addEventListener`**： 你可以使用 `addEventListener` 来监听 `message` 事件，这是最常见的方式，也是推荐的做法。\n\n    ```javascript\n    ws.addEventListener('message', (event) => {\n        const receivedMessage = event.data;\n        console.log('Received message from server:', receivedMessage);\n        // 在这里处理接收到的消息\n    });\n    ```\n\n2. **使用 `onmessage` 属性**： 除了使用 `addEventListener`，你还可以直接设置 `onmessage` 属性来指定消息处理函数。这与之前的示例相似，但更简洁：\n\n    ```javascript\n    ws.onmessage = function (event) {\n        const receivedMessage = event.data;\n        console.log('Received message from server:', receivedMessage);\n        // 在这里处理接收到的消息\n    };\n    ```\n\n## 发送消息\n\n**发送消息到服务器**： 使用 `send()` 方法将消息发送到服务器：\n\n```javascript\nws.send('Hello, server!'); // 发送消息给服务器\n```\n\n## 关闭连接\n\n**关闭 WebSocket 连接**： 要关闭 WebSocket 连接，你可以简单地使用 `WebSocket.close()` 方法，例如：\n\n```javascript\nws.close();\n```\n\n如果 WebSocket 连接的 `readyState` 已经处于 `CLOSE` 状态，那么该方法不会执行任何操作\n\n检查 WebSocket 是否打开： 你可以通过检查 `WebSocket` 的 `readyState` 属性来判断 WebSocket 是否打开。如果 `readyState` 的值为 `WebSocket.OPEN`，则表示连接已打开：\n\n```javascript\nif (ws.readyState === WebSocket.OPEN) {\n    // WebSocket 连接已打开\n}\n```\n\n这样你就可以在代码中判断 WebSocket 是否处于打开状态了\n\n## 处理\n\n**处理连接状态**： 你可以监听其他事件，例如 `open`、`close` 和 `error`，以处理连接的不同状态：\n\n```javascript\nws.addEventListener('open', (event) => {\n    console.log('WebSocket 已连接');\n});\n\nws.addEventListener('close', (event) => {\n    console.log('WebSocket 连接已关闭');\n});\n\nws.addEventListener('error', (event) => {\n    console.error('WebSocket 连接出现异常:', event.error);\n});\n```\n\n\n\n同样可以使用onclose 、 onerror 、 onopen 属性定义时间监听函数。\n\n# 在 Spring Boot 中整合、使用 WebSocket\n\nWebSocket 是一种基于 TCP 协议的全双工通信协议，它允许客户端和服务器之间建立持久的、双向的通信连接。相比传统的 HTTP 请求 - 响应模式，WebSocket 提供了实时、低延迟的数据传输能力。通过 WebSocket，客户端和服务器可以在任意时间点互相发送消息，实现实时更新和即时通信的功能。WebSocket 协议经过了多个浏览器和服务器的支持，成为了现代 Web 应用中常用的通信协议之一。它广泛应用于聊天应用、实时数据更新、多人游戏等场景，为 Web 应用提供了更好的用户体验和更高效的数据传输方式。\n\n本文将会指导你如何在 Spring Boot 中整合、使用 WebSocket，以及如何在 `@ServerEndpoint` 类中注入其他 Bean 依赖 。\n\n在 Spring Boot 中使用 WebSocket 有 2 种方式。第 1 种是使用由 Jakarta EE 规范提供的 Api，也就是 `jakarta.websocket` 包下的接口。第 2 种是使用 spring 提供的支持，也就是 [`spring-websocket`](https://github.com/spring-projects/spring-framework/tree/main/spring-websocket) 模块。前者是一种独立于框架的技术规范，而后者是 Spring 生态系统的一部分，可以与其他 Spring 模块（如 Spring MVC、Spring Security）无缝集成，共享其配置和功能。\n\n2 种方式各有优劣，你可以按需选择。本文将使用第 1 种方式，也就是使用 `jakarta.websocket` 来开发 WebSocket 应用。\n\n软件版本：\n\n- Spring Boot：`3.1.3`\n\n## 在 Spring Boot 中整合 WebSocket\n\n### 添加依赖\n\n在 `pom.xml` 中添加 `spring-boot-starter-websocket` 依赖。\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-websocket</artifactId>\n</dependency>\n```\n\n### 开发 ServerEndpoint 端点\n\n服务端 WebSocket 端点的开发也有 2 种方式。第 1 种是实现规范所提供的各种接口，通过接口定义的回调方法来处理新的连接、客户端消息、连接断开等等事件。另一种方式是使用注解，类似于 Spring 中的 Controller，通过在方法上使用不同的注解来监听不同的 WebSocket 事件，灵活性比较高，推荐使用。\n\n我们打算创建一个 `echo` 端点，该端点会处理客户端的连接、断开、消息事件。在收到消息后，我们会在消息前面加上服务器时间戳和 `Hello` 前缀，原样写回给客户端。如果客户端发送的消息为 `bye`，则服务器会主动断开与客户端的连接。\n\n```java\npackage cn.springdoc.demo.channel;\n\nimport java.io.IOException;\nimport java.time.Instant;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport jakarta.websocket.CloseReason;\nimport jakarta.websocket.EndpointConfig;\nimport jakarta.websocket.OnClose;\nimport jakarta.websocket.OnError;\nimport jakarta.websocket.OnMessage;\nimport jakarta.websocket.OnOpen;\nimport jakarta.websocket.Session;\nimport jakarta.websocket.server.ServerEndpoint;\n\n// 使用 @ServerEndpoint 注解表示此类是一个 WebSocket 端点\n// 通过 value 注解，指定 websocket 的路径\n@ServerEndpoint(value = \"/channel/echo\")\npublic class EchoChannel {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(EchoChannel.class);\n\n    private Session session;\n\n    // 收到消息\n    @OnMessage\n    public void onMessage(String message) throws IOException{\n        \n        LOGGER.info(\"[websocket] 收到消息：id={}，message={}\", this.session.getId(), message);\n        \n        if (message.equalsIgnoreCase(\"bye\")) {\n            // 由服务器主动关闭连接。状态码为 NORMAL_CLOSURE（正常关闭）。\n            this.session.close(new CloseReason(CloseReason.CloseCodes.NORMAL_CLOSURE, \"Bye\"));;\n            return;\n        }\n        \n        \n        this.session.getAsyncRemote().sendText(\"[\"+ Instant.now().toEpochMilli() +\"] Hello \" + message);\n    }\n\n    // 连接打开\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig endpointConfig){\n        // 保存 session 到对象\n        this.session = session;\n        LOGGER.info(\"[websocket] 新的连接：id={}\", this.session.getId());\n    }\n\n    // 连接关闭\n    @OnClose\n    public void onClose(CloseReason closeReason){\n        LOGGER.info(\"[websocket] 连接断开：id={}，reason={}\", this.session.getId(),closeReason);\n    }\n\n    // 连接异常\n    @OnError\n    public void onError(Throwable throwable) throws IOException {\n        \n        LOGGER.info(\"[websocket] 连接异常：id={}，throwable={}\", this.session.getId(), throwable.getMessage());\n        \n        // 关闭连接。状态码为 UNEXPECTED_CONDITION（意料之外的异常）\n        this.session.close(new CloseReason(CloseReason.CloseCodes.UNEXPECTED_CONDITION, throwable.getMessage()));\n    }\n}\n```\n\n首先，使用 `@ServerEndpoint` 注解表示此类是一个 WebSocket 端点，`value` 属性是必须的，用于设置路由。它还有其他的一些可选属性可以用于自定义子协议、消息编码器、消息解码器、握手处理器等等，篇幅原因这里不展开。\n\n#### @OnMessage\n\n`@OnMessage` 注解用于监听客户端消息事件，它只有一个属性 `long maxMessageSize() default -1;` 用于限制客户端消息的大小，如果小于等于 0 则表示不限制。当客户端消息体积超过这个阈值，那么服务器就会主动断开连接，状态码为：`1009`。方法的参数可以是基本的 `String` / `byte[]` 或者是 `Reader` / `InputStream`，分别表示 WebSocket 中的文本和二进制消息。也可以是自定义的 Java 对象，但是需要在 `@ServerEndpoint` 中配置对象的解码器（`jakarta.websocket.Decoder`）。对于内容较长的消息，支持分批发送，可以在消息参数后面定义一个布尔类型的 `boolean last`参数，如果该值为 `true` 则表示此消息是批次消息中的最后一条。\n\n```java\n@OnMessage\npublic void onMessage(String message, boolean last) throws IOException{\n    if (last) {\n            // 这是批量消息的最后一条\n    }\n}\n```\n\n#### @OnOpen\n\n`@OnOpen` 方法用于监听客户端的连接事件，它没有任何属性。可以作为方法参数的对象有很多，`Session` 对象是必须的，表示当前连接对象，我们可以通过此对象来执行发送消息、断开连接等操作。WebSocket 的连接 URL，类似于 Http 的 URL，也可以传递查询参数、path 参数。通常用于传递认证、鉴权用的 Token 或其他信息。\n\n要获取查询参数，我们可以通过 `Session` 的 `getRequestParameterMap();` 获取。\n\n```java\nMap<String, List<String>> query = session.getRequestParameterMap();\n```\n\n要获取 path 参数，首先要在 `@ServerEndpoint` 中定义 path 参数，类似于 Spring Mvc 的 path 参数定义。例如： `@ServerEndpoint(value = \"/channel/echo/{id}\")`。那么我们可以在 `@OnOpen` 方法中使用 `@PathParam` 注解接收，如下：\n\n```java\n@ServerEndpoint(value = \"/channel/echo/{id}\")\n\n...\n\n@OnOpen\npublic void onOpen(Session session, @PathParam(\"id\") Long id, EndpointConfig endpointConfig){\n    ....\n}\n```\n\n示例中的最后一个参数 `EndpointConfig` ，它是可选，用于获取全局的一些配置。在本文中未用到。\n\n#### @OnClose\n\n`@OnClose` 用于处理连接断开事件，参数中可以指定一个 `CloseReason` 对象，它封装了断开连接的状态码、原因信息。\n\n#### @OnError\n\n`@OnError` 用于处理异常事件，**该方法必须要有一个 `Throwable` 类型的参数**，表示发生的异常。否则应用会启用失败：\n\n```txt\nCaused by: jakarta.websocket.DeploymentException: No Throwable parameter was present on the method [onError] of class [cn.springdoc.demo.channel.EchoChannel] that was annotated with OnError\n    at org.apache.tomcat.websocket.pojo.PojoMethodMapping.getPathParams(PojoMethodMapping.java:311) ~[tomcat-embed-websocket-10.1.12.jar:10.1.12]\n    at org.apache.tomcat.websocket.pojo.PojoMethodMapping.<init>(PojoMethodMapping.java:194) ~[tomcat-embed-websocket-10.1.12.jar:10.1.12]\n    at org.apache.tomcat.websocket.server.WsServerContainer.addEndpoint(WsServerContainer.java:130) ~[tomcat-embed-websocket-10.1.12.jar:10.1.12]\n    at org.apache.tomcat.websocket.server.WsServerContainer.addEndpoint(WsServerContainer.java:240) ~[tomcat-embed-websocket-10.1.12.jar:10.1.12]\n    at org.apache.tomcat.websocket.server.WsServerContainer.addEndpoint(WsServerContainer.java:198) ~[tomcat-embed-websocket-10.1.12.jar:10.1.12]\n    at org.springframework.web.socket.server.standard.ServerEndpointExporter.registerEndpoint(ServerEndpointExporter.java:156) ~[spring-websocket-6.0.11.jar:6.0.11]\n    ... 12 common frames omitted\n```\n\n所有事件方法，都支持使用 `Session` 作为参数，表示当前连接参数。但是为了更加方便，我们在 `@OnOpen` 事件中直接把 `Session` 存储到了当前对象中，可以在任意方法中使用 `this` 访问。服务器会为每个连接创建一个端点对象，所以这是线程安全的。\n\n上面还提到了一个 “连接关闭状态码”，WebSocket 协议定义了一系列状态码来表示连接断开的原因，这些状态码定义在了 `CloseReason.CloseCodes` 枚举中。\n\n### 配置 ServerEndpointExporter\n\n定义好端点后，需要在配置类中通过定义 `ServerEndpointExporter` Bean 进行注册。\n\n```java\npackage cn.springdoc.demo.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.socket.server.standard.ServerEndpointExporter;\n\nimport cn.springdoc.demo.channel.EchoChannel;\n\n@Configuration\npublic class WebSocketConfiguration {\n\n    @Bean  \n    public ServerEndpointExporter serverEndpointExporter (){\n        \n        ServerEndpointExporter exporter = new ServerEndpointExporter();\n        \n        // 手动注册 WebSocket 端点\n        exporter.setAnnotatedEndpointClasses(EchoChannel.class);\n        \n        return exporter;\n    }  \n}\n```\n\n你也可以在 WebSocket 端点上添加 `@Component` 注解，使用 Spring 自动扫描，这样的话不需要手动调用 `setAnnotatedEndpointClasses` 方法进行注册。\n\n## 测试\n\n在项目的 `src/main/resources` 目录下创建一个 `public` 文件夹，再在此文件夹中新建一个 `index.html` 文件，作为 WebSocket 客户端。内容如下：\n\n> Spring Boot 默认会把 `public` 目录下的 `index.html` 作为应用主页。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>WebSocket</title>\n</head>\n<body>\n    <script type=\"text/javascript\">\n        let websocket = new WebSocket(\"ws://localhost:8080/channel/echo\");\n        \n        // 连接断开\n        websocket.onclose = e => {\n            console.log(`连接关闭: code=${e.code}, reason=${e.reason}`)\n        }\n        // 收到消息\n        websocket.onmessage = e => {\n            console.log(`收到消息：${e.data}`);\n        }\n        // 异常\n        websocket.onerror = e => {\n            console.log(\"连接异常\")\n            console.error(e)\n        }\n        // 连接打开\n        websocket.onopen = e => {\n            console.log(\"连接打开\");\n            \n            // 创建连接后，往服务器连续写入3条消息\n            websocket.send(\"sprigdoc.cn\");\n            websocket.send(\"sprigdoc.cn\");\n            websocket.send(\"sprigdoc.cn\");\n            \n            // 最后发送 bye，由服务器断开连接\n            websocket.send(\"bye\");\n            \n            // 也可以由客户端主动断开\n            // websocket.close();\n        }\n    </script>\n</body>\n</html>\n```\n\n内容很简单，网页加载后运行 Javascript 代码。立即创建与 `ws://localhost:8080/channel/echo` 的 WebSocket 连接对象，通过注册对象的各种监听方法来处理事件。\n\n在连接就绪后，也就是在 `onopen` 方法中往服务器端点发送了 3 条消息。按照逻辑，服务端也会回复 3 条消息，这会触发 `onmessage` 事件，把消息内容输出到控制台。最后，发送 `bye`，服务器收到消息后会主动断开连接，这就会触发 `onclose` 事件，把 “连接关闭状态码” 和原因输出到控制台。\n\n> 其实你可以直接把这段 Javascript 代码复制到任意支持 WebSocket 的浏览器的控制台执行，WebSocket 没有跨域的说法！\n\n启动应用，打开浏览器（先打开控制台），然后访问 `http://localhost:8080/`，查看控制台输出的日志：\n\n```txt\n连接打开\n收到消息：[1694505275009] Hello sprigdoc.cn\n收到消息：[1694505275012] Hello sprigdoc.cn\n收到消息：[1694505275014] Hello sprigdoc.cn\n连接关闭: code=1000, reason=Bye\n```\n\n再看看服务端控制台日志：\n\n```txt\ncn.springdoc.demo.channel.EchoChannel    : [websocket] 新的连接：id=0\ncn.springdoc.demo.channel.EchoChannel    : [websocket] 收到消息：id=0，message=sprigdoc.cn\ncn.springdoc.demo.channel.EchoChannel    : [websocket] 收到消息：id=0，message=sprigdoc.cn\ncn.springdoc.demo.channel.EchoChannel    : [websocket] 收到消息：id=0，message=sprigdoc.cn\ncn.springdoc.demo.channel.EchoChannel    : [websocket] 收到消息：id=0，message=bye\ncn.springdoc.demo.channel.EchoChannel    : [websocket] 连接断开：id=0，reason=CloseReason: code [1000], reason [Bye]\n```\n\n没有任何问题，一切按照我们预定义的逻辑在运行。客户端发送 3 条消息，服务器响应 3 条消息，最后断开连接。客户端、服务器相应的事件方法都成功执行。\n\n服务端日志中的 sessionId（`id=0`），是通过 `Session` 的 `String getId();` 方法获取的。服务器会为每个连接分配一个不同的 id 值，不同服务器生成的 id 类型不一样。 Tomcat 使用从 0 开始的自增值（本例），Undertow 使用的是类似于 UUID 的 32 位长度的字符串。\n\n## 在端点中注入 Bean\n\n往往我们需要在端点中使用其他 Spring 管理的 Bean 来完成业务，例如认证、鉴权、保存消息。。。等等。\n\n假如我们有一个 `UserService` 服务类，内容如下：\n\n```java\npackage cn.springdoc.demo.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserService {\n    public void foo() {}\n\n    // ....\n}\n```\n\n我们现在要在端点中注入使用它，很多人会直接在端点类上使用 `@Component` 注解，然后注入：\n\n```java\n@ServerEndpoint(value = \"/channel/echo\")\n@Component  // 注册为 Spring 组件\npublic class EchoChannel {\n\n    @Autowired // 注入需要的 Bean\n    private UserService userService;\n\n    // ...\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig endpointConfig){\n\n        this.session = session;\n\n        // 在业务中使用\n        this.userService.foo();\n    }\n}\n```\n\n服务可以正常启动，看似一切都没问题！可是当你在事件方法中使用这 Bean 的时候就会导致 `NullPointerException` 异常。\n\n```txt\njava.lang.NullPointerException: Cannot invoke \"cn.springdoc.demo.service.UserService.foo()\" because \"this.userService\" is null\n    at cn.springdoc.demo.channel.EchoChannel.onOpen(EchoChannel.java:54)\n    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.base/java.lang.reflect.Method.invoke(Method.java:568)\n    at org.apache.tomcat.websocket.pojo.PojoEndpointBase.doOnOpen(PojoEndpointBase.java:67)\n    at org.apache.tomcat.websocket.pojo.PojoEndpointServer.onOpen(PojoEndpointServer.java:46)\n    at org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.init(WsHttpUpgradeHandler.java:131)\n    at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:936)\n    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)\n    at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)\n    at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\n    at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\n    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n    at java.base/java.lang.Thread.run(Thread.java:833)\n```\n\n**原因：运行时的 WebSocket 连接对象，也就是端点实例，是由服务器创建，而不是 Spring，所以不能使用自动装配**。上文也提到过 “服务器会为每个连接创建一个端点实例对象”。\n\n知道了原因后，解决办法也很简单，我们可以使用 Spring 的 `ApplicationContextAware` 接口，在应用启动时获取到 `ApplicationContext` 并且保存在全局静态变量中。\n\n服务器每次创建连接的时候，我们就在 `@OnOpen` 事件方法中从 `ApplicationContext` 获取到需要 Bean 来初始化端点对象。\n\n```java\n@ServerEndpoint(value = \"/channel/echo\")\n@Component  // 由 spring 扫描管理\npublic class EchoChannel implements\n                ApplicationContextAware { // 实现 ApplicationContextAware 接口， Spring 会在运行时注入 ApplicationContext\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(EchoChannel.class);\n\n    // 全局静态变量，保存 ApplicationContext\n    private static ApplicationContext applicationContext;\n\n    private Session session;\n\n    // 声明需要的 Bean\n    private UserService userService;\n\n\n    // 保存 Spring 注入的 ApplicationContext 到静态变量\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        EchoChannel.applicationContext = applicationContext;\n    }\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig endpointConfig){\n        \n        // 保存 session 到对象\n        this.session = session;\n        \n        // 连接创建的时候，从 ApplicationContext 获取到 Bean 进行初始化\n        this.userService = EchoChannel.applicationContext.getBean(UserService.class);\n        \n        // 在业务中使用\n        this.userService.foo();\n        \n        LOGGER.info(\"[websocket] 新的连接：id={}\", this.session.getId());\n    }\n    // ....\n}\n```\n\n`onOpen` 方法在整个连接的生命周期中，只会执行一次，所以这种方式不会带来通信时的性能损耗。",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 25,
        "thumbNum": 4,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1645799822881509377",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-03-11 12:45:20",
        "updateTime": "2024-03-12 21:18:10",
        "user": {
          "id": "1645799822881509377",
          "planetCode": "14255",
          "userName": "为",
          "userAvatar": null,
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-10-01 21:19:43",
          "lastLoginTime": null,
          "createTime": "2023-04-11 22:43:49",
          "updateTime": "2024-01-30 14:21:10"
        },
        "tags": [
          "文章",
          "Java",
          "Spring",
          "Javascript"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1762409253202681858",
        "title": "Redis学习（List 、Hash）",
        "description": null,
        "content": "### Redis列表(List)\n\nRedis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部或尾部（两端都可以添加）。 \n\nRedis List列表的底层是双端链表，最多可以包含2^32-1个元素，主要操作是push/pop等，一般用在栈、队列、消息队列等场景。\n\nPS：List结构是单key多value，如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。由于List的底层是一个双向列表，因此其对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。\n\n#### 常用命令\n\n1. 创建list以及查看list\n\n   - lpush\n\n     > lpush命令将一个或多个值插入到列表的头部，如果key不存在，一个空列表会被创建并执行lpush命令，返回值为执行lpush命令后列表的长度，如果key存在但不是列表类型时，返回一个错误提示。\n\n     基本语法：\n\n     ```shell\n     lpush key_name value1...valueX\n     ```\n\n     示例代码：\n\n     ```shell\n     redis 127.0.0.1:6379> LPUSH list1 \"foo\"\n     (integer) 1\n     ```\n\n   - rpush\n\n     > lpush会将一个或多个值插入到列表的尾部（最右边）。如果key不存在，一个空列表会被创建并执行rpush命令，返回值为执行rpush命令后列表的长度，如果key存在但不是列表类型时，返回一个错误提示。\n\n     基本语法：\n\n     ```shell\n     rpush key_name value1...valueX\n     ```\n\n     示例代码：\n\n     ```shel\n     redis 127.0.0.1:6379> RPUSH mylist \"hello\"\n     (integer) 1\n     ```\n\n   - lrange\n\n     > lrange返回列表中指定区间内的元素，区间以偏移量start和end指定。其中0代表列表中的第一个元素，1代表列表中的第二个元素，以此类推。除此以外，你也可以负数下标，-1代表列表中的最后一个元素，-2代表列表中的倒数第二个元素，以此类推。\n\n     基本语法：\n\n     ```shell\n     lrange key_name start end\n     ```\n\n     示例代码：\n\n     ```shell\n     redis 127.0.0.1:6379> LPUSH list1 \"foo\"\n     (integer) 1\n     redis 127.0.0.1:6379> LPUSH list1 \"bar\"\n     (integer) 2\n     redis 127.0.0.1:6379> LRANGE list1 0 -1\n     1) \"foo\"\n     2) \"bar\"\n     ```\n\n2. 移除并获取List中的元素\n\n   - lpop\n\n     > lpop命令用于移除并返回列表中的第一个元素。当列表key不存在时，返回nil。\n\n     基本语法：\n\n     ```shell\n     lpop key_name\n     ```\n\n     示例代码：\n\n     ```shell\n     redis 127.0.0.1:6379> lpush list1 1 2 3 4 5\n     (integer) 5\n     redis 127.0.0.1:6379> lpop list1\n     5\n     ```\n\n   - rpop\n\n     > rpop命令用于移除并返回列表中的最后一个元素。当列表key不存在时，返回nil。\n\n     基本语法：\n\n     ```shell\n     rpop key_name\n     ```\n\n     示例代码：\n\n     ```shell\n     redis 127.0.0.1:6379> lpush list1 1 2 3 4 5\n     (integer) 5\n     redis 127.0.0.1:6379> rpop list1\n     1\n     ```\n\n     \n\n3. 通过索引获取列表中的元素(lindex)\n\n   > lindex命令用于通过索引获取列表中的元素。索引也可以采用负数，-1代表列表中的最后一个元素，-2代表列表中的倒数第二个元素。返回值为列表中下标为指定索引值的元素，如果指定索引值不在列表的区间范围内，返回nil。\n\n   基本语法：\n\n   ```shell\n   lindex key_name index_position\n   ```\n\n   示例代码：\n\n   ```shell\n   redis 127.0.0.1:6379> lpush list1 1 2 3 4 5\n   (integer) 5\n   redis 127.0.0.1:6379> lindex list1 1\n   4\n   ```\n\n4. 获取列表长度(llen)\n\n   > llen命令用于返回列表的长度，如果列表key不存在，则key被解释为一个空列表，返回0；如果key不是列表类型，返回一个错误。\n\n   基本语法：\n\n   ```shell\n   llen key_name\n   ```\n\n   示例代码：\n\n   ```shell\n   redis 127.0.0.1:6379> lpush list1 1 2 3 4 5\n   (integer) 5\n   redis 127.0.0.1:6379> llen list1\n   5\n   ```\n\n5. 移除列表元素(lrem)\n\n   > lrem命令用于移除列表中参数count个值为value的元素。返回值为被移除元素的数量，如果列表不存在，则返回0。\n   >\n   > count = 0时，移除列表中所有与value相等的元素。\n   >\n   > 当count>0时，从表头开始向表尾搜索，移除与value相等的元素，数量为count。\n   >\n   > 当count<0时，从表尾开始向表头搜索，移除与value相等的元素，数量为count。\n\n   基本语法：\n\n   ```shell\n   lrem key_name count value\n   ```\n\n   示例代码：\n\n   ```shell\n   redis 127.0.0.1:6379> lpush list1 1 1 1 1 2 3 4 5\n   (integer) 8\n   redis 127.0.0.1:6379> lrem list1 2 1\n   2\n   ```\n\n6. 截取指定范围的值后再赋值给key(ltrim)\n\n   > ltrim对一个列表进行修剪，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。下标 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。命令执行成功时，返回 ok 。\n\n   基本语法：\n\n   ```shell\n   ltrim key_name start stop\n   ```\n\n   示例代码：\n\n   ```shell\n   redis 127.0.0.1:6379> lpush list1 1 2 3 4 5 6\n   (integer) 6\n   redis 127.0.0.1:6379> ltrim list1 1 3\n   ok\n   ```\n\n7. rpoplpush 源列表 目的列表\n\n   > 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。返回值为被移除的元素。\n\n   基本语法：\n\n   ```shell\n   rpoplpush source_key_name destination_key_name\n   ```\n\n   示例代码：\n\n   ```shell\n   redis 127.0.0.1:6379> lpush list1 1 2 3\n   (integer) 3\n   redis 127.0.0.1:6379> lpush list2 4 5 6\n   (integer) 3\n   redis 127.0.0.1:6379> rpoplpush list1 list2\n   3\n   ```\n\n8. 通过索引设置列表元素的值\n\n   > lset命令用于通过索引来设置元素的值。当索引超过范围，或对一个空的列表进行lset，会返回一个错误，操作成功时，会返回ok。\n\n   基本语法：\n\n   ```shell\n   lset key_name index value\n   ```\n\n   示例代码：\n\n   ```shell\n   redis 127.0.0.1:6379> lpush list1 1 2 3 4 5 6\n   (integer) 6\n   redis 127.0.0.1:6379> lset list1 1 8\n   ok\n   ```\n\n9. 在列表的元素前或者后插入元素\n\n   > Redis Linsert 命令用于在列表的元素前或者后插入元素。 当指定元素不存在于列表中时，不执行任何操作。 当列表不存在时，被视为空列表，不执行任何操作。 如果 key 不是列表类型，返回一个错误。如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到指定元素 ，返回 -1 。 如果 key 不存在或为空列表，返回 0 。\n\n   基本语法：\n\n   ```shell\n    LINSERT KEY_NAME BEFORE EXISTING_VALUE NEW_VALUE \n   ```\n\n   ### 实例\n\n   ```\n   redis 127.0.0.1:6379> RPUSH list1 \"foo\"\n   (integer) 1\n   redis 127.0.0.1:6379> RPUSH list1 \"bar\"\n   (integer) 2\n   redis 127.0.0.1:6379> LINSERT list1 BEFORE \"bar\" \"Yes\"\n   (integer) 3\n   redis 127.0.0.1:6379> LRANGE mylist 0 -1\n   1) \"foo\"\n   2) \"Yes\"\n   3) \"bar\"\n   ```\n\n### Redis哈希表(Hash)\n\nRedis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。\n\nRedis 中每个 hash 可以存储 2^32 - 1 键值对（40多亿）\n\n#### 常用命令\n\n1. hset/hget/hmset/hmget/hgetall/hdel\n\n   - hset\n\n     > hset命令用于为哈希表中的字段赋值。如果哈希表不存在，一个新的哈希表会被创建并进行hset操作；如果字段已经存在于哈希表中，旧值会被新值覆盖。如果字段是哈希表中的一个新的字段，并且设置值成功，返回1。如果哈希表中字段已经存在且旧值已经被覆盖，则返回0。\n\n     基本语法：\n\n     ```shell\n     HSET KEY_NAME FIELD VALUE\n     ```\n\n     示例代码：\n\n     ```shell\n     redis 127.0.0.1:6379> hset user:001 id 1\n     ok\n     ```\n\n   - hget\n\n     >hget命令用于返回哈希表中指定字段的值。返回值为指定字段的值，如果指定字段或key不存在时，返回nil。\n\n     基本语法：\n\n     ```shell\n     hget key_name field_name\n     ```\n\n     示例代码：\n\n     ```shell\n     redis 127.0.0.1:6379> hset user:001 name lisi\n     ok\n     redis 127.0.0.1:6379> hget user:001 name\n     lisi\n     ```\n\n   - hmset\n\n     > hmset命令用于同时将多个field-value设置到哈希表中，此命令会覆盖哈希表中已存在的字段，如果哈希表不存在，会创建一个空的哈希表，并执行还没set命令。如果命令执行成功，则返回ok。\n\n     基本语法：\n\n     ```shell\n     hmset key_name field1 value1 ... fieldn valuen\n     ```\n\n     示例代码：\n\n     ```shell\n     redis 127.0.0.1:6379> hmset user:001 id 1 name zhangsan age 18\n     ok\n     ```\n\n   - hmget\n\n     > hmget命令用于返回哈希表中的一个或多个指定字段的值，如果指定的字段不存在于哈希表，会返回一个nil。如果命令执行成功，返回一个包含多个指定字段关联值的表，顺序与指定字端的请求顺序一样。\n\n     基本语法：\n\n     ```shell\n     hmget key_name field1 ... fieldn\n     ```\n\n     示例代码：\n\n     ```shell\n     redis 127.0.0.1:6379> hmset user:001 id 1 name lisi age 18\n     ok\n     redis 127.0.0.1:6379> hmget user:001 id name age\n     1\n     lisi\n     18\n     ```\n\n   - hgetall\n\n     > hgetall命令用于返回哈希表中，所有的字段和值。在返回值里，紧跟每个字段名之后的是字段的值，所以返回值的长度是哈希表长的两倍。如果key不存在，返回空列表。\n\n     基本语法：\n\n     ```shell\n     hgetall key_name\n     ```\n\n     示例代码：\n\n     ```shell\n     redis 127.0.0.1:6379> hmset user:001 id 1 name lisi\n     ok\n     redis 127.0.0.1:6379> hgetall user:001\n     id\n     1\n     name\n     lisi\n     ```\n\n   - hdel\n\n     > hdel命令用于删除哈希表key中d阿一个或多个指定字段，不存在的字段将会忽略。命令执行成功会返回被删除字段的数量，不包括被忽略的字段。\n\n     基本语法：\n\n     ```shell\n     hdel key_name field1 ... fieldn\n     ```\n\n     示例代码：\n\n     ```shell\n     redis 127.0.0.1:6379> hset user:001 id 1 age 18\n     ok\n     redis 127.0.0.1:6379> hdel user:001 id\n     1\n     ```\n\n2. hlen\n\n   > hlen命令用于获取哈希表中字段的数量。返回值为哈希表中字段的数量，若key不存在时，返回0。\n\n   基本语法：\n\n   ```shell\n   hlen key_name\n   ```\n\n   示例代码：\n\n   ```shell\n   redis 127.0.0.1:6379> hmset user:001 id 1 name lisi age 18\n   ok\n   redis 127.0.0.1:6379> hlen user:001\n   3\n   ```\n\n3. hexists key\n\n   > hexists命令用于查看哈希表的指定字段是否存在，返回结果为1时，代表哈希表含有指定的字段；返回结果为0时，\n\n   基本语法：\n\n   ```shell\n   hexists key field_name\n   ```\n\n   示例代码：\n\n   ```shell\n   redis 127.0.0.1:6379> hmset user:001 id 1 name lisi age 18\n   ok\n   redis 127.0.0.1:6379> hexists user:001 id\n   1\n   ```\n\n4. hkeys/hvals\n\n   - hkeys\n\n     > hkeys命令用于查看哈希表中的字段名，可以理解为Map集合的keySet方法，返回值为哈希表中的所有的字段，当key不存在时，返回一个空列表。\n\n     基本语法：\n\n     ```shell\n     hkeys key_name\n     ```\n\n     示例代码：\n\n     ```shell\n     redis 127.0.0.1:6379> hmset user:001 id 1 name lisi age 18\n     ok\n     redis 127.0.0.1:6379> hkeys user:001\n     id\n     name\n     age\n     ```\n\n   - hvals\n\n     > hvals命令用于获取哈希表中所有字段的值。命令执行成功会返回一个包含所有哈希表中所有字段的值，若可以不存在，返回一个空列表。\n\n     基本语法：\n\n     ```shell\n     hvals key_name\n     ```\n\n     示例代码：\n\n     ```shell\n     redis 127.0.0.1:6379> hmset user:001 id 1 name lisi age 18\n     ok\n     redis 127.0.0.1:6379> hvals user:001\n     1\n     lisi\n     18\n     ```\n\n5. hincrby/hincrbyfloat\n\n   - hincrby\n\n     > hincrby命令用于为哈希表中字段的值加上指定的增量值，增量值也可以是一个负数，相当于对哈希表中的字段值进行减操作。若key不存在，则会创建新的哈希表并进行hincrby操作。如果指定的字段不存在，则该字段的初始值为0。\n     >\n     > 命令执行成功后，返回被修改后的字段的值。\n     >\n     > PS：对存储字符串值的字段进行hincrby命令则会返回一个错误。另外本操作的值被限制在 64 位(bit)有符号数字表示之内。\n\n     基本语法：\n\n     ```shell\n     hincrby key_name field_name incr_by_number\n     ```\n\n     示例代码：\n\n     ```shell\n     redis 127.0.0.1:6379> hmset user:001 id 1 name lisi age 18\n     ok\n     redis 127.0.0.1:6379> hincrby user:001 age 2\n     20\n     ```\n\n   - hincrbyfloat\n\n     > hincrbyfloat命令用于为哈希表中字段的值加上指定的浮点增量值。如果指定的字段不存在，则该字段的初始值为0。\n     >\n     > 命令执行成功后，返回被修改后的字段的值。\n\n     基本语法：\n\n     ```shell\n     hincrbyfloat key_name field_name incr_by_number\n     ```\n\n     示例代码：\n\n     ```shell\n     redis 127.0.0.1:6379> hset user:001 weight 60.5 height 170\n     ok\n     redis 127.0.0.1:6379> hincrbyfloat user:001 weight 0.5\n     61.0\n     ```\n\n6. hsetnx\n\n   > hsetnx命令用于为哈希表中不存在的字段赋值，如果字段已经存在在哈希表中，则操作失效。\n   >\n   > 如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。\n   >\n   > 如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令。\n   >\n   > 设置成功，返回 1 。 如果给定字段已经存在且没有操作被执行，返回 0 。\n\n   基本语法：\n\n   ```shell\n   hsetnx key_name field value\n   ```\n\n   示例代码：\n\n   ```shell\n   redis 127.0.0.1:6379> hsetnx user:001 address local\n   (integer) 1\n   ```",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 40,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1608812742599245826",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-27 17:28:04",
        "updateTime": "2024-03-11 23:55:12",
        "user": {
          "id": "1608812742599245826",
          "planetCode": "5185",
          "userName": "葛成",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/sqZ24tHwumJ8fHiabmZOqemicECaic6INZmtXAOzf6lXq4P7NaPwiaCLW29O7cc3v1JGibnMuse3mJcVNCtnw4LBwrQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 3,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-04-22 12:22:23",
          "lastLoginTime": null,
          "createTime": "2022-12-30 21:10:22",
          "updateTime": "2024-02-24 10:11:42"
        },
        "tags": [
          "文章",
          "笔记",
          "Redis"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1762022491125047297",
        "title": "大四java-准备春招",
        "description": "简历",
        "content": "鱼皮哥，今年大四了，准备参加现在的春招，\n- 想找您看看目前建立还有什么问题么？\n- 我一直没输过算法题，现在刷是不是没有必要了？\n- 我一直到现在才约了3场面试，感觉很紧张，我很头疼这个问题。。。\n\n![c3acbdb62bcbf87aa1250af72e695c0.png](https://pic.code-nav.cn/post_picture/1681534941206155266/fKEyG721-c3acbdb62bcbf87aa1250af72e695c0.png)",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 263,
        "thumbNum": 4,
        "favourNum": 5,
        "commentNum": 0,
        "priority": 0,
        "userId": "1681534941206155266",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-26 15:51:13",
        "updateTime": "2024-03-13 09:18:38",
        "user": {
          "id": "1681534941206155266",
          "planetCode": "24896",
          "userName": "放纵",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1681534941206155266/8TcWogu9-csdn头像.jpg",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-07-19 12:46:39",
          "lastLoginTime": null,
          "createTime": "2023-07-19 13:22:26",
          "updateTime": "2024-02-26 15:29:44"
        },
        "tags": [
          "文章",
          "简历"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1761043295141748738",
        "title": "MySQL学习",
        "description": "关于MySQL约束的学习",
        "content": "## 约束\n#### 1、概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。\n#### 2、目的：保证数据库中数据的正确、有效性和完整性。\n#### 3、分类：\n\n| 约束 | 描述 |  关键字  | \n| --- | --- |---|\n| 非空约束 | 限制该字段的数据不能为null | not null|\n|唯一约束|\t保证该字段的所有数据都是唯一，不重复\t|unique|\n|主键约束|\t主键是一行数据的唯一标识，要求非空且唯一（自增：auto_increment）|\tprimary key|\n|默认约束\t|保存数据时，如果未指定该字段的值，则采用默认值\t|default|\n|检查约束（8.0.16版本之后）|保证字段值满足某一个条件\t|check|\n|外键约束\t|用来让两张表的数据之间建立连接，保证数据的一致性和完整性|\tforeign key|\n\n*注意：\n约束是作用于表中字段上的，可以创建表/修改表的时候添加约束。*\n\n外键约束：\n具有外键的是子表，外键所关联的是父表\n语法如下：\n\n```sql\n-- 添加外键\ncreate table 表名(\n  字段名 数据类型，\n  ...\n  [constraint] [外键名称] foreign key(外键名称) references 主表(主表列名)\n  \n);\n-- 或者\nalter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(主表列名)\n```\n\n```sql\n-- 删除外键\nalter table 表名 drop foreign key 外键名称 \n\n```\n外键的删除/更新行为\n\n| 行为 | 说明 |\n| --- | --- |\n| no action | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与RESTRICT一致) |\n| restrict | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与NOACTON 一致) |\n| cascade | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。 |\n| set null | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为nul(这就要求该外键允许取null)。 |\n| set default | 父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持) |\n\n设置外键行为语法\n\n```sql\nalter table 表名 add constraint 外键名称 foreign key (外键字段) references 主表名(主表字段名) on update cascade on delete cascade\n-- on updae 意思是在更新时采取什么行为\n-- on delete 意思是在删除时采取什么行为\n```\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 50,
        "thumbNum": 0,
        "favourNum": 2,
        "commentNum": 0,
        "priority": 0,
        "userId": "1747537878507896833",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-23 23:00:14",
        "updateTime": "2024-03-12 22:19:39",
        "user": {
          "id": "1747537878507896833",
          "planetCode": "32623",
          "userName": "划船不用桨",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1747537878507896833/ZVW3Wp8C-微信图片_20240221213145.jpg",
          "gender": 1,
          "userProfile": "打工仔一个",
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": "1997-09-03",
          "school": "",
          "major": null,
          "education": "专科",
          "graduationYear": 2021,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": 2,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2025-02-18 08:59:43",
          "lastLoginTime": null,
          "createTime": "2024-01-17 16:34:32",
          "updateTime": "2024-02-22 09:18:45"
        },
        "tags": [
          "文章",
          "数据库"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1760679073350279169",
        "title": "模板引擎-Thymeleaf与Freemarker",
        "description": "关于模板引擎Thymeleaf与Freemarker的笔记",
        "content": "# 模板引擎\n\n模板引擎：将数据和页面显示分离。\n\n模板文件 + 数据  -->  模板引擎  -->  html\n\n通过正则表达式来识别哪些是固定不变的模板，哪些是变化的数据，用已有的API（如：不同的表达式类型）把什么样的数据用什么格式来渲染进去，根据提供好的规则，模板引擎就可以解析出来。\n\nJSP的局限性\n\n1）springboot内嵌容器时（打成jar包），不支持JSP。\n如果要运行JSP需要打成war包，则需要使用外部容器。\n\n2）undertow容器是不支持JSP的。\n\n3）扩展性有限，对于一些默认处理，很难自定义。\n\n4）在容器化技术（如docket）中，对JSP的使用也很繁杂。\n\n\n因为JSP有这么多的局限性，所以有了模板引擎\n\n\n较早的模板引擎：velocity、freemarker\n\n国人开发的模板：beetl\n\n\n# Thymeleaf\n\n自然的模板，动静分离，是一个处理纯文本的模板引擎。\n\n## 引入thymeleaf命名空间\n\n```html\n<!--引入thymeleaf的命名空间，使用时才有提示-->\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n```\n\n## 表达式\n\n`${}` 变量表达式，引用一个变量\n\n`*{}` 选择变量表达式，当我们通过${}拿到一个对象时，可以通过*{}拿到这个对象的属性值\n\n`#{}` 消息表达式，可以通过配置文件拿到某些数据，还可以用来实现国际化效果 \n\n`@{}` 链接表达式\n\n`~{}` 片段表达式，引用相同的代码片段\n\n\n## 字符串的拼接\n\n```html\n<p th:text=\"${person.name} + ' is ' + ${person.age}\"></p>\n<!--使用 | 将${}的内容替换成对象，其余的不变-->\n<p th:text=\"|${person.name} is ${person.age}|\"></p>\n```\n\n## 条件判断\n\n### if的使用\n\n```html\n<p th:if=\"${msg=='yes'}\">这是第一个msg的取值：</p>\n<p th:text=\"${msg}\" th:if=\"${msg=='yes'}\"></p>\n<p th:if=\"${msg=='no'}\">这是第二个msg的取值：</p>\n<p th:text=\"${msg}\" th:if=\"${msg=='no'}\"></p>\n```\n\n### unless的使用\n\n```html\n<p th:unless=\"${msg=='yes'}\">这是第一个msg的取值：</p>\n<p th:text=\"${msg}\" th:unless=\"${msg=='yes'}\"></p>\n<!--当msg的值不等于no时进行展示，所以下面的会展示出来-->\n<p th:unless=\"${msg=='no'}\">这是第二个msg的取值：</p>\n<p th:text=\"${msg}\" th:unless=\"${msg=='no'}\"></p>\n```\n\n### switch的使用\n\n```html\n<div th:switch=\"${num}\">\n\t<p th:case=\"1\">1</p>\n\t<p th:case=\"2\">2</p>\n\t<p th:case=\"*\">*</p>\n</div>\n```\n\n## for循环\n\n### th:each\n\n```html\n<table>\n    <thead>\n\t<tr>\n            <th>名字</th>\n            <th>年龄</th>\n\t</tr>\n    </thead>\n    <tbody>\n\t<tr th:each=\"data:${list}\">\n            <td th:text=\"${data.name}\">name</td>\n            <td th:text=\"${data.age}\">age</td>\n\t</tr>\n    </tbody>\n</table>\n```\n\n### 状态变量\n\n默认命名是：参数名+Stat（如上的：dataStat），用来**保存迭代状态**\n\n自定义的命名是：`<tr th:each=\"data,status:${list}\">` 此时状态变量名为status\n\n状态变量的属性：\n```\nindex\t索引，从0开始\ncount\t计数，从1开始\nsize\t\t集合的大小\ncurrent\t当前对象\nfirst / last\t布尔类型，是否是第一个/最后一个\neven / odd\t布尔类型，是否是 偶数 / 奇数 个\n```\n\n```html\n<table>\n\t<thead>\n\t<tr>\n\t\t<th>名字</th>\n\t\t<th>年龄</th>\n\t\t<th>index</th>\n\t\t<th>count</th>\n\t\t<th>size</th>\n\t\t<th>current</th>\n\t\t<th>first</th>\n\t\t<th>last</th>\n\t\t<th>even</th>\n\t\t<th>odd</th>\n\t</tr>\n\t</thead>\n\t<tbody>\n\t<tr th:each=\"data:${list}\">\n\t\t<td th:text=\"${data.name}\">name</td>\n\t\t<td th:text=\"${data.age}\">age</td>\n\t\t<td th:text=\"${dataStat.index}\">index</td>\n\t\t<td th:text=\"${dataStat.count}\">count</td>\n\t\t<td th:text=\"${dataStat.size}\">size</td>\n\t\t<td th:text=\"${dataStat.current}\">current</td>\n\t\t<td th:text=\"${dataStat.first}\">first</td>\n\t\t<td th:text=\"${dataStat.last}\">last</td>\n\t\t<td th:text=\"${dataStat.even}\">even</td>\n\t\t<td th:text=\"${dataStat.odd}\">odd</td>\n\t</tr>\n\t</tbody>\n</table>\n```\n\n## URL的使用\n\n### 基础使用\n\n```html\n<form th:action=\"@{/login}\" method=\"post\">\n\tusername:\n\t<input type=\"text\" name=\"username\">\n\tpassword:\n\t<input type=\"password\" name=\"password\">\n\t\n\t<input type=\"submit\" value=\"提交\">\n</form>\n```\n\n### 绝对路径\n\n#### 1、基本用法\n\n```html\n<a th:href=\"@{http://cn.bing.com}\">外链到：bing</a>\n<!--渲染效果为<a href=\"http://cn.bing.com\">外链到：bing</a>-->\n```\n\n#### 2、协议自动识别补全\n\n**使用方法：\t开头用 //**\n\n以引用静态资源举例：\n\n```html\n<script type=\"text/javascript\" th:src=\"@{//code.jquery.com/jquery-3.4.1.min.js}\"></script>\n```\n\n渲染结果：\n`<script type=\"text/javascript\" src=\"[//code.jquery.com/jquery-3.4.1.min.js](http://code.jquery.com/jquery-3.4.1.min.js)\"></script>`\n\n### 相对路径\n\n#### 1、上下文相关的URL\n\n##### 1）基本用法\n\n`<form th:action=\"@{/login}\" method=\"post\">`\n比如说：部署项目的地址\tlocalhost:8080/demo\n渲染结果为： <form action=\"/demo/login\" method=\"post\">\n验证方式：在配置文件中增加`server.servlet.context-path=/demo`\n\n##### 2）引用静态资源的方式\n\n先利用springboot的依赖配置\n\n```xml\n<dependency>\n    <groupId>org.webjars</groupId>\n    <artifactId>jquery</artifactId>\n    <version>3.4.1</version>\n</dependency>\n```\n\n接着在某个html文件中引用\n\n```html\n<script type=\"text/javascript\" th:src=\"@{/webjars/jquery/3.4.1/jquery.js}\"></script>\n```\n\n##### 3）参数的使用\n\n请求中携带参数\n    \na）携带一个参数时，如：/addPerson?id=1\n       在表达式中使用：@{/addPerson(id=1)}\t\t\n       **单个参数的使用，用括号括起来**\n    \nb）携带多个参数时，如：/addPerson?id=1&name='lsq'\n      在表达式中使用：@{/addPerson(id=1,name='lsq')}\t\n      **用括号将多个参数括起来，参数之间用逗号隔开**\n    \nc）当参数是路径的一部分时，如：\t/addPerson/1?name='lsq'\n      在表达式中使用：@{/addPerson/{id}(id=1,name='lsq')}\n      **支持路径中包含变量  可以使用参数去替换**\n\n#### 2、服务器相关URL\n\n` <a th:href=\"@{~/a.html}\"></a> `\n\n通过 **~** 知道指定的是服务器某个地址，就不是和项目相关的，这样不同的项目可以访问同一个服务器下的某个文件。\n    \n渲染结果为：`<a href=\"/a.html\">`\n    \n**不会增加上下文路径（项目访问路径），可以访问同一个服务器上的不同项目，访问到固定地址。**\n\n**补充：**\n\n![image1.png](https://pic.code-nav.cn/post_picture/1632761346305089537/iaJ4pFBS-image1.png)\n\n    \n## 内置对象/内嵌变量\n\n工具类的使用：（使用方式是\t**加前缀#**）\n    \ndates、calendars、numbers、strings、objects、bools、arrays、lists、sets、Maps\n\n日期dates\n    \n日期格式化：#datas.format()\n\n```html\n<!--dates的使用-->\n<p th:text=\"${date}\"></p>\n<p th:text=\"${#dates.format(date,'yyyy-MM-dd HH:mm:ss')}\"></p>\n\n<!--拿到当前的时间-->\n<p  th:text=\"${#dates.createNow()}\"></p>\n<p th:text=\"${#dates.createToday()}\"></p>\n```\n\nstrings的使用\n\n```html\n<!--strings的使用-->\n<p th:text=\"${#strings.isEmpty(str)}\"></p>\n<p th:text=\"${#strings.length(str)}\"></p>\n<p th:text=\"${#strings.equals(str,'duing')}\"></p>\n```\n\n\n## 表达式语言\n\nOGNL：Object-Graph Navigation Language 对象视图导航语言\n\n可以通过表达式语言，来获取Java的对象，在JavaWeb中使用较多\n\nSpEL：基于Spring的表达式语言，提供给我们一种运行时对象的交互能力\n本质都是\t在视图层和控制层将数据建立联系的方式\n\n```html\n<p th:text=\"${ 1 * 2 + 3 - 4}\"></p>\n\n<p th:text=\"${list[0].name}\"></p>\n\n<p th:text=\"${T(java.lang.Math).random()}\"></p>\n```\n\n## 内联表达式\n\n用两个中括号 **[ [ ] ]** 将一个引用的对象括起来，对象本身还是 **${}** 获取，这样就能将展示的信息与其它字符串拼接起来了。（展示文本的时候简化逻辑）\n    \n凡是可以用 th:text 或 th:utext 显示的内容都可以用内联表达式来转换。\n\n`th:text`\t=>\t`[[...]]`\t转义了，若含有标签，标签效果不起作用\n    \n`th:utext`\t=>\t`[(...)]`    不转义，按照标签效果输出\n如果文本需要展示含`[[]]`的数据，可以禁用内联表达式。\n\n```html\n<p> 加油，[[${info}]] </p>\n<p> 加油，<span th:text=\"${info}\"></span> </p>\n\n<!--禁用内联表达式-->\n<p th:inline=\"none\"> 加油，[[<span th:text=\"${info}\"></span>]] </p>\n```\n\n**内联JavaScript**\n    \n当给JavaScript中传一些数据的时候，使用内联JavaScript\n\n```html\n<script type=\"text/javascript\" th:inline=\"javascript\">\n\t//var info = [[${info}]];\n\t<!--内联js，同样支持动静分离,使用 /**/ 将动态数据引起来，在其后跟上静态数据，但这样使用之后原来的注释就不能用了，同时还有一个局限性：在外部js文件里不能使用，在html文件中的js代码生效 -->\n\tvar info = /*[[${info}]]*/ 123;\n\tconsole.log(info);\n</script>\n```\n\n类似js，同样支持css\n\n```html\n<style th:inline=\"css\">\n</style>\n```\n\n## 碎片代码\n\n**th:fragment，th:include，th:replace，th:insert**\n    \n有些网页内容，需要在许多网页中使用，可以使用`th:fragment`在某个独立的（网页）标签中设置碎片代码，并为其命名。\n    \n在需要引入碎片代码的网页中使用`th:include、th:replace、th:insert`等引入。\n    \n**include，replace，insert的区别：**\n\n- include是只引进碎片代码的内容，不把其标签属性引入（即不引入碎片标签），保留原有的标签属性\n- replace与include相反，只引入碎片代码的内容，引入碎片标签，不保留原有的标签\n- insert是即引入碎片标签，也保留原有标签（当样式冲突时，碎片标签属性起作用，看网页源码可知）\n\n\n![image2.png](https://pic.code-nav.cn/post_picture/1632761346305089537/EDPke2QY-image2.png)\n    \n\n# Freemarker\n\n一个用java编写的模板引擎，适合作为web项目中的视图层组件，是生成文本的工具。\n    \nftl文件本质也是html格式的\n    \nfreemarker区分大小写\n    \nftl组成部分：文本（静态的），插值（动态的），标签，注释 **<#--  -->** \n\n## 使用步骤\n\n**1）引入freemarker依赖**\n\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-freemarker</artifactId>\n</dependency>\n```\n\n**2）增加自定义的配置文件**\n\n```properties\n#旧的使用方式\n# 文件位置\n#spring.mvc.view.prefix=/templates\n# 文件后缀\n#spring.mvc.view.suffix=.ftl\n\n#新的使用方式\n# 文件位置\nspring.freemarker.template-loader-path=classpath:/templates\n# 文件后缀\nspring.freemarker.suffix=.ftl\n```\n\n**3）编写controller及ftl文件**\n\n## 字符串的使用\n\n定义变量：**<#assign** info1 = 'how are you?'>\n字符串的拼接：<p>Hello ${info **+** info1}</p>\n字符串的内嵌函数：（调用时使用 **字符串名?** ）\n\n<p>${info1?substring(0,3)}</p>\t<#--左闭右开-->\n<p>${info1?length}</p>\n\n```html\n<p>Hello ${info}</p><br>\n\n<#--定义变量-->\n<#assign info1 = 'how are you?'>\n<#--字符串的拼接-->\n<p>Hello ${info + info1}</p>\n<#--字符串的内嵌函数-->\n<p>${info1?substring(0,3)}</p><#--左闭右开-->\n<p>${info1?length}</p>\n```\n\n## 条件判断\n\n```html\n<#assign num = 666>\n<#if num == 666>\n\t<p>666</p>\n<#elseif num == 888>\n\t<p>888</p>\n<#else>\n\t<p>000</p>\n</#if>\n```\n\n```html\n<#switch num>\n\t<#case 666>\n\t\t<p>666</p>\n\t\t<#break>\n\t<#case 888>\n\t\t<p>888</p>\n\t\t<#break>\n\t<#default>\n\t\t<p>000</p>\n</#switch>\n```\n\n## 列表\n\n```html\n<#assign myList = [1,3,5,7,10,9]>\n<h5>无序数组：</h5>\n<#list myList as item>\n\t${item}\n</#list>\n<br>\n<h5>有序数组：</h5>\n<#list myList?sort as item>\n\t${item}\n</#list>\n<br>\n\t\n<#list [1,2,3] as item>\n\t${item}\n</#list>\n<br>\n\t\n<#list 1..3 as item>\n\t${item}\n</#list>\n<br>\n\t\n<#--元素的别名 缀上 _index  代表下标-->\n<#list 1..3 as item>\n\t${item_index}\t<#--获取索引-->\n\t, ${item}<br>\n</#list>\n\t\n<#list 1..3 as item>\n\t<#--判断是否有下一项-->\n\t<#if item_has_next>\n\t\t${item}\n\t</#if>\n</#list>\n```\n\n## 判断变量是否为空\n\n```html\n<#--判断变量是否为空：通过 ! 来判断-->\n<#--<#assign str = 'str'>-->\n${str!\"default\"}\n```\n\n## 引入其它文件的值\n\n在一个html中引入另一个html中的一些变量的值，不仅能读取，还能修改\n\n```html\n<#import 'other.ftl' as otherFtl>\n${otherFtl.name} <br>\n<#--不仅可以读取到它的值，还能修改它的值-->\n<#assign name = 'welcome ftl is here' in otherFtl>\n${otherFtl.name}\n```\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 27,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1632761346305089537",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-22 22:52:57",
        "updateTime": "2024-03-07 22:07:54",
        "user": {
          "id": "1632761346305089537",
          "planetCode": "18875",
          "userName": "举个栗子~",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1632761346305089537/y7rrvMgi-可达鸭头像.png",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [
            "面试题",
            "面试题挑战",
            "简历",
            "面试",
            "开源",
            "软件"
          ],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2025-03-06 21:53:57",
          "lastLoginTime": null,
          "createTime": "2023-03-06 23:13:34",
          "updateTime": "2024-02-22 21:57:59"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1760652938952433665",
        "title": "常见设计模式在星球OJ和聚合搜索项目中的应用",
        "description": "介绍星球OJ和聚合搜索项目中使用的常用设计模式",
        "content": "在近期的开发中，笔者主要参与了星球OJ（[OJ 判题系统（亮点多） - 飞书云文档 (feishu.cn)](https://yuyuanweb.feishu.cn/wiki/LhjxwgFjwiovTVk9w2vcJoj4nid)）和聚合搜索（[聚合搜索平台（中台设计） - 飞书云文档 (feishu.cn)](https://yuyuanweb.feishu.cn/wiki/RigVw1gAdiXIfLkj6ktclEDQn7e)）两个项目。在这两个项目中，均使用了设计模式来使代码变得“优雅”。直观来说，让代码的简洁度、可读性和拓展性都得到了一定程度的提升。\n\n正所谓“学以致用”，那么就跟着笔者的节奏，来从以上两个项目的实际场景中来学习和体会设计模式吧~\n\n## 1. OJ项目\n\n主要使用的设计模式有：\n\n1. 代理模式\n2. 工厂模式\n3. 策略模式\n4. 模板方法模式\n\n### 1.1. 代码沙箱的开发：模板方法模式\n\n（引自菜鸟教程）\n\n在模板方法模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。\n\n**意图：**定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n**主要解决：**一些方法通用，却在每一个子类都重新写了这一方法。\n\n**优点：** 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。\n\n**缺点：**每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n\n**使用场景：** 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。\n\n![S3s2W.png](https://i0.imgs.ovh/2024/02/21/S3s2W.png)\n\n在代码沙箱的开发中，针对不同代码语言的代码执行，逻辑都是相同的，只是在具体实现的方法细节存在差异。因此，我们可以通过提取“执行代码”共有的逻辑和方法，封装至模板类中，然后创建不同语言的“执行代码子类”交由“客户端”来调用和处理对应的代码语言，得到执行结果。\n\n**首先，**我们提取并创建“执行代码”抽象类角色![S3xIv.png](https://i0.imgs.ovh/2024/02/21/S3xIv.png)\n\n**然后，**我们针对不同的语言，继承公共类，得到对应的子类（以处理Java语言代码的子类为例）：\n\n![S3Kze.png](https://i0.imgs.ovh/2024/02/21/S3Kze.png)\n\n**而且，**在子类中，我们除了可以使用父类已有的方法，也可以实现抽象方法，也可以自行添加对应的方法，比如，Java需要编译代码，那么我们就可以添加“编译代码”方法，Python无需编译，则无需添加此方法。\n\n### 1.2. 代码沙箱对象的生成：工厂模式\n\n（引自菜鸟教程）\n\n工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n工厂模式提供了一种创建对象的方式，而无需指定要创建的具体类。\n\n工厂模式属于创建型模式，它在创建对象时提供了一种封装机制，将实际创建对象的代码与使用代码分离。\n\n**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n\n**何时使用：**我们明确地计划不同条件下创建不同实例时。\n\n**优点：** 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。\n\n**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\n\n**注意事项：**作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n\n**工厂模式包含以下几个核心角色：**\n\n- 抽象产品（Abstract Product）：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。\n- 具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。\n- 抽象工厂（Abstract Factory）：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。\n- 具体工厂（Concrete Factory）：实现了抽象工厂接口，负责实际创建具体产品的对象。\n\n![S3oC3.png](https://i0.imgs.ovh/2024/02/21/S3oC3.png)\n\n在OJ系统中，我们需要再判题时调用“代码沙箱”服务，而代码沙箱的种类通常不止一种，比如：远程第三方代码沙箱、本地代码沙箱、其他厂商代码沙箱等，对此我们首先会将其交由不同的子类来处理（实现同一代码沙箱接口），然后**针对不同的条件，来创建不同的子类沙箱对象**来使用，这时，就可以用到工厂模式。\n\n**首先，**我们拥有若干种类的“代码沙箱”子类：\n\n![S3Sm9.png](https://i0.imgs.ovh/2024/02/21/S3Sm9.png)\n\n**然后，**我们创建代码沙箱工厂类来根据选择的条件来生成相应的子类对象：\n\n![S3ucO.png](https://i0.imgs.ovh/2024/02/21/S3ucO.png)\n\n**最后，**我们在使用时，只需指定对应的“代码沙箱type”，即可得到对应的代码沙箱使用对象：\n\n![S379H.png](https://i0.imgs.ovh/2024/02/21/S379H.png)\n\n### 1.3. 代码沙箱对象方法的调用：代理模式\n\n（引自菜鸟教程）\n\n在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。\n\n在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。\n\n**意图：**为其他对象提供一种代理以控制对这个对象的访问。\n\n**主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。\n\n**如何解决：**增加中间层，实现与被代理类组合。\n\n**优点：** 1、职责清晰。 2、高扩展性。 3、智能化。\n\n**缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。\n\n**主要涉及到以下几个核心角色：**\n\n- **抽象主题（Subject）:**\n\n- - 定义了真实主题和代理主题的共同接口，这样在任何使用真实主题的地方都可以使用代理主题。\n\n- **真实主题（Real Subject）:**\n\n- - 实现了抽象主题接口，是代理对象所代表的真实对象。客户端直接访问真实主题，但在某些情况下，可以通过代理主题来间接访问。\n\n- **代理（Proxy）:**\n\n- - 实现了抽象主题接口，并持有对真实主题的引用。代理主题通常在真实主题的基础上提供一些额外的功能，例如延迟加载、权限控制、日志记录等。\n\n- **客户端（Client）:**\n\n- - 使用抽象主题接口来操作真实主题或代理主题，不需要知道具体是哪一个实现类。\n\n![S3QHD.png](https://i0.imgs.ovh/2024/02/21/S3QHD.png)\n\n承接1.2，在得到“代码沙箱子类对象”后，我们要调用其“执行代码”的方法，但我们希望能够在执行原方法的同时添加一些额外的操作（如，打印方法日志），同时不影响原方法，那么就可以创建一个代理类，来代理原代码沙箱子类对象。\n\n**首先，**创建代理类：\n\n![S3RSo.png](https://i0.imgs.ovh/2024/02/21/S3RSo.png)\n\n**然后，**就可以使用代理类去调用“执行代码（新）”方法：\n\n![S3cdA.png](https://i0.imgs.ovh/2024/02/21/S3cdA.png)\n\n### 1.4. 多语言代码的判题：策略模式\n\n（引自菜鸟教程）\n\n在策略模式（Strategy Pattern）中一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。\n\n在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。\n\n在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。\n\n**意图：**定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。\n\n**主要解决：**在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。\n\n**何时使用：**一个系统有许多许多类，而区分它们的只是他们直接的行为。\n\n**如何解决：**将这些算法封装成一个一个的类，任意地替换。\n\n**关键代码：**实现同一个接口。\n\n**优点：** 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。\n\n**缺点：** 1、策略类会增多。 2、所有策略类都需要对外暴露。\n\n**使用场景：** 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。\n\n**策略模式包含以下几个核心角色：**\n\n- 环境（Context）：维护一个对策略对象的引用，负责将客户端请求委派给具体的策略对象执行。环境类可以通过依赖注入、简单工厂等方式来获取具体策略对象。\n- 抽象策略（Abstract Strategy）：定义了策略对象的公共接口或抽象类，规定了具体策略类必须实现的方法。\n- 具体策略（Concrete Strategy）：实现了抽象策略定义的接口或抽象类，包含了具体的算法实现。\n\n策略模式通过将算法与使用算法的代码解耦，提供了一种动态选择不同算法的方法。客户端代码不需要知道具体的算法细节，而是通过调用环境类来使用所选择的策略。\n\n![S3g25.png](https://i0.imgs.ovh/2024/02/21/S3g25.png)\n\n在OJ系统中，不同语言代码的题目判题，方法相同，但方法的具体实现策略有所不同，因此可以使用策略模式来根据代码语言“环境”的不同选择不同的算法策略。\n\n**首先，**创建不同语言的策略子类（实现统一抽象判题接口）：\n\n![S3ths.png](https://i0.imgs.ovh/2024/02/21/S3ths.png)\n\n**然后，**创建“上下文对象”来统一“环境”类的参数：\n\n![S31UX.png](https://i0.imgs.ovh/2024/02/21/S31UX.png)\n\n**最后，**就可以创建“环境”类，来实现动态切换策略：\n\n![S3zCU.png](https://i0.imgs.ovh/2024/02/21/S3zCU.png)\n\n## 2. 聚合搜索项目\n\n主要使用的设计模式有：\n\n1. 适配器模式\n2. 注册器模式\n\n### 2.1. 多数据源搜索接口调用：适配器模式\n\n（引自菜鸟教程）\n\n适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。\n\n这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。\n\n**优点：** 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。\n\n**缺点：** 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。\n\n**使用场景：**有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。\n\n**注意事项：**适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。\n\n![S3U60.png](https://i0.imgs.ovh/2024/02/21/S3U60.png)\n\n在聚合搜索项目中，我们需要从不同数据源中检索数据，那么就需要调用不同数据源接口的方法，而这些方法一般方法参数都存在差异，我们无法直接方便的统一调用，只能使用分支结构做复杂的代码逻辑，此时我们就可以引入适配器模式，将分支结构的代码从客户端调用方拆分后移至抽象适配器接口的各个子类中，统一适配器类的参数，从而方便客户端便捷、统一的使用。\n\n**首先，**创建适配器接口，制定统一的规范，即统一方法名和参数格式：\n\n![S3ieC.png](https://i0.imgs.ovh/2024/02/21/S3ieC.png)\n\n**然后，**实现不同数据源的实现子类（实现适配器接口）：\n\n![S3j9t.png](https://i0.imgs.ovh/2024/02/21/S3j9t.png)\n\n![S35Mm.png](https://i0.imgs.ovh/2024/02/21/S35Mm.png)\n\n**最后，**客户端即可通过适配器接口，来统一获取不同数据源的查询结果：\n\n![S3YSN.png](https://i0.imgs.ovh/2024/02/21/S3YSN.png)\n\n### 2.2. 特定搜索接口子类对象使用：注册器模式\n\n注册器模式是一种基础常见的设计模式，它的主要意思是把多个类的实例注册到一个注册器类中去，然后需要哪个类，由这个注册器类统一调取。\n\n（引自ChatGPT）\n\n- **优点**：\n\n- - 提供了一种统一的注册和查找机制，使得系统更加灵活，易于维护和扩展。\n  - 可以动态地向注册器中注册和移除对象，实现了松耦合。\n\n- **缺点**：\n\n- - 可能会导致注册器对象过于庞大，难以维护和理解。\n  - 对象的生命周期由注册器管理，可能会导致内存泄漏或者对象过早被销毁的问题。\n\n实现起来也很简单，在聚合搜索项目中，可以将“适配器接口”的各个子类加入同一注册器，便于统一调取，从而减少了客户端调用方法的代码量：\n\n![S3ddR.png](https://i0.imgs.ovh/2024/02/21/S3ddR.png)\n\n![S3DFp.png](https://i0.imgs.ovh/2024/02/21/S3DFp.png)",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 36,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1721896042632441858",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-22 21:09:06",
        "updateTime": "2024-03-13 00:27:42",
        "user": {
          "id": "1721896042632441858",
          "planetCode": "29240",
          "userName": "南侠（准）",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELkfM4IsxxWrB70flGuaDcq55mDxh8r4DuwOJLuluSmRCH9Pk1MFibry5icVgHtfwMmnYGqT49svVKV3X1wMer2OCC3ob5leZX5lF8HMbPo1Qww/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 2,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-11-05 22:14:23",
          "lastLoginTime": null,
          "createTime": "2023-11-07 22:23:02",
          "updateTime": "2024-02-02 08:50:41"
        },
        "tags": [
          "文章",
          "后端",
          "笔记"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1760560210990194690",
        "title": "伙伴匹配引入 GEO 实现搜索附近用户",
        "description": "伙伴匹配引入 Reids GEO 实现搜索附近用户功能",
        "content": "## 前言\n\n鱼皮哥在直播中提出可以通过Redis GEO实现编辑距离和搜索附近用户功能，也算是是一个拓展点。这个项目我做完有一个多月了，最近在做其拓展功能顺便也把这个功能实现一波，整体的实现并不困难，学完 Redis 再看会更轻松（未学过也没事）。话不多说直接开始撸代码吧。\n\n### 设计思路和流程\n1. 在 User（用户）表中添加两个字段 longitude（经度）和 dimension（维度），用以存储用户的经纬度坐标。因为Redis GEO 通过每个用户的经纬度坐标计算用户间的距离，同时其 Redis 数据类型为ZSET，ZSET 是一个有序的 List 类似 Java 的 SortedSet。在此场景 value 就是用户id，score 是经纬度信息（ ZSET 根据 score值升序排序）。\n\n![image.png](https://pic.code-nav.cn/post_picture/1608639807578177538/ukGNy7Pm-image.png)\n\n```sql\ncreate table hjj.user\n(\n    username     varchar(256)                       null comment '用户昵称',\n    id           bigint auto_increment comment 'id'\n        primary key,\n    userAccount  varchar(256)                       null comment '账户',\n    avatarUrl    varchar(1024)                      null comment '用户头像',\n    gender       tinyint                            null comment '用户性别',\n    profile      varchar(512)                       null comment '个人简介',\n    userPassword varchar(512)                       not null comment '用户密码',\n    phone        varchar(128)                       null comment '电话',\n    email        varchar(512)                       null comment '邮箱',\n    userStatus   int      default 0                 not null comment '状态 0 - 正常',\n    createTime   datetime default CURRENT_TIMESTAMP null comment '创建时间',\n    updateTime   datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment '更新时间',\n    isDelete     tinyint  default 0                 not null comment '是否删除',\n    userRole     int      default 0                 not null comment '用户角色 0 - 普通用户 1 - 管理员',\n    planetCode   varchar(512)                       null comment '星球编号',\n    tags         varchar(1024)                      null comment '标签列表(json)',\n    longitude    decimal(10, 6)                     null comment '经度',\n    dimension    decimal(10, 6)                     null comment '纬度'\n)\n    comment '用户';\n```\n\n2. 在 UserVO 类中添加distance字段，用以向前端返回每个用户与自己之间的距离，类型为Double。\n\n```java\n/**\n * 用户信息封装类\n */\n@Data\npublic class UserVO {\n    /**\n     * id\n     */\n    private long id;\n\n    /**\n     * 用户昵称\n     */\n    private String username;\n\n    /**\n     * 账户\n     */\n    private String userAccount;\n\n    /**\n     * 用户头像\n     */\n    private String avatarUrl;\n\n    /**\n     * 用户性别\n     */\n    private Integer gender;\n    /**\n     * 用户简介\n     */\n    private String profile;\n\n    /**\n     * 电话\n     */\n    private String phone;\n\n    /**\n     * 邮箱\n     */\n    private String email;\n\n    /**\n     * 状态 0 - 正常\n     */\n    private Integer userStatus;\n\n    /**\n     * 创建时间\n     */\n    private Date createTime;\n\n    /**\n     * 更新时间\n     */\n    private Date updateTime;\n\n    /**\n     * 用户角色 0 - 普通用户 1 - 管理员\n     */\n    private Integer userRole;\n\n    /**\n     * 星球编号\n     */\n    private String planetCode;\n    /**\n     * 标签列表 json\n     */\n    private String tags;\n\n    /**\n     * 用户距离\n     */\n    private Double distance;\n\n    private static final long serialVersionUID = 1L;\n}\n```\n\n\n## 基本业务实现\n\n### 导入各个用户经纬度数据\n编写测试类导入各个用户的经纬度信息并且写入Redis中，Redis GEO会根据它计算出一个 score值。进行 Redis GEO 相关操作时可以使用 Spring Data Redis 提供现成的操作 Redis 的模板——StringRedisTemplate，注意其 Key/Value 都是String类型。\n\nstringRedisTemplate.opsForGeo().add() 支持一次一次地传入经纬度信息，可以通过List和Map集合类型传入用户经纬度信息，这里我们用List集合。第一个参数为Redis的key，这不用过多介绍。第二个参数为List类型，泛型为RedisGeoCommands.GeoLocation<String>，其参数为用户id和Point（Point可以理解为是一个圆的一个点吧，经纬度就是x/y坐标）。\n\nstringRedisTemplate.opsForGeo().add()传入的参数：\n\n![image.png](https://pic.code-nav.cn/post_picture/1608639807578177538/aCG2wGnt-image.png)\n\n```java\n    @Test\n    public void importUserGEOByRedis() {\n        List<User> userList = userService.list(); // 查询所有用户\n        String key = RedisConstant.USER_GEO_KEY; // Redis的key\n        List<RedisGeoCommands.GeoLocation<String>> locationList = new ArrayList<>(userList.size()); // 初始化地址（经纬度）List\n        for (User user : userList) {\n            locationList.add(new RedisGeoCommands.GeoLocation<>(String.valueOf(user.getId()), new Point(user.getLongitude(),\n                    user.getDimension()))); // 往locationList添加每个用户的经纬度数据\n        }\n        stringRedisTemplate.opsForGeo().add(key, locationList); // 将每个用户的经纬度信息写入Redis中\n    }\n```\n\n结果：\n\n![image.png](https://pic.code-nav.cn/post_picture/1608639807578177538/hAnnMABF-image.png)\n\n\n### 获取用户 id = 1 与其他用户的距离\n编写一个测试类计算用户 id = 1 与其他用户之间的距离。利用stringRedisTemplate.opsForGeo().distance()方法，其主要参数为member1和member2，Metric是计算距离的单位类型。从名称就可以知道member1和member2其实就是用户1和用户2的信息，因为我们在上面用 locationList.add() 添加用户id和用户的经度坐标，所以这两个member就是用户id咯。\n\n所以写个循环就可以算出用户 id = 1 与其他用户的距离\n```java\n    @Test\n    public void getUserGeo() {\n        String key = RedisConstant.USER_GEO_KEY;\n        List<User> userList = userService.list();\n\n        // 计算每个用户与登录用户的距离\n        for (User user : userList) {\n            Distance distance = stringRedisTemplate.opsForGeo().distance(key,\n                    \"1\", String.valueOf(user.getId()), RedisGeoCommands.DistanceUnit.KILOMETERS);\n            System.out.println(\"User: \" + user.getId() + \", Distance: \" +\n                    distance.getValue() + \" \" + distance.getUnit());\n        }\n    }\n```\n\n结果：\n\n![image.png](https://pic.code-nav.cn/post_picture/1608639807578177538/lYSYVUBZ-image.png)\n\n### 搜索附近用户\n\n利用现成的 stringRedisTemplate.opsForGeo().radius 方法，第一个参数依然是Redis的key，第二个参数是Circle，看代码和名称就知道其是一个圆（传入Point即圆心和圆的半径）。想象搜索附近的用户就是搜索以你为圆心，半径为搜索距离的圆内的用户。理解这些代码就能顺理成章的撸出来了，是不是不算难。\n\n```java\n    @Test\n    public void searchUserByGeo() {\n        User loginUser = userService.getById(1);\n        Distance geoRadius = new Distance(1500, RedisGeoCommands.DistanceUnit.KILOMETERS);\n        Circle circle  = new Circle(new Point(loginUser.getLongitude(), loginUser.getDimension()), geoRadius);\n        RedisGeoCommands.GeoRadiusCommandArgs geoRadiusCommandArgs = RedisGeoCommands.GeoRadiusCommandArgs\n                .newGeoRadiusArgs().includeCoordinates();\n        GeoResults<RedisGeoCommands.GeoLocation<String>> results = stringRedisTemplate.opsForGeo().radius(RedisConstant.USER_GEO_KEY, circle, geoRadiusCommandArgs);\n        for (GeoResult<RedisGeoCommands.GeoLocation<String>> result : results) {\n            if (!result.getContent().getName().equals(\"1\")) {\n                System.out.println(result.getContent().getName()); // 打印1500km内的用户id\n            }\n        }\n    }\n```\n\n注意：搜索附近的用户会搜索到自己，所以可以加一个判断以排除自己。\n\n结果：\n\n![image.png](https://pic.code-nav.cn/post_picture/1608639807578177538/LKL1E1ne-image.png)\n\n## 应用至伙伴匹配项目\n\n### 改写用户推荐接口\n我的recommend接口未从Redis缓存中读取数据，而是直接走数据库读取数据，有能力的可以自己实现，我后续也会实现的。同时注意返回类型是UserVO不是User，因为我的前端展示了推荐用户和自己之间的距离。\n\nUserController.recommendUsers:\n```java\n    @GetMapping(\"/recommend\")\n    public BaseResponse<List<UserVO>> recommendUsers(long pageSize, long pageNum, HttpServletRequest request){\n        User loginUser = userService.getLoginUser(request);\n        QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n        queryWrapper.ne(\"id\", loginUser.getId());\n        IPage<User> page = new Page<>(pageNum, pageSize);\n        IPage<User> userIPage = userService.page(page, queryWrapper);\n\n        String redisUserGeoKey = RedisConstant.USER_GEO_KEY;\n        // 将User转换为UserVO\n        List<UserVO> userVOList = userIPage.getRecords().stream()\n                .map(user -> {\n                    // 查询距离\n                    Distance distance = stringRedisTemplate.opsForGeo().distance(redisUserGeoKey,\n                            String.valueOf(loginUser.getId()), String.valueOf(user.getId()),\n                            RedisGeoCommands.DistanceUnit.KILOMETERS);\n                    double value = distance.getValue();\n\n                    // 创建UserVO对象并设置属性\n                    UserVO userVO = new UserVO();\n                    // 这里可以用BeanUtils.copyProperties()，就没必要重复set了\n                    userVO.setId(user.getId());\n                    userVO.setUsername(user.getUsername());\n                    userVO.setUserAccount(user.getUserAccount());\n                    userVO.setAvatarUrl(user.getAvatarUrl());\n                    userVO.setGender(user.getGender());\n                    userVO.setProfile(user.getProfile());\n                    userVO.setPhone(user.getPhone());\n                    userVO.setEmail(user.getEmail());\n                    userVO.setUserStatus(user.getUserStatus());\n                    userVO.setCreateTime(user.getCreateTime());\n                    userVO.setUpdateTime(user.getUpdateTime());\n                    userVO.setUserRole(user.getUserRole());\n                    userVO.setPlanetCode(user.getPlanetCode());\n                    userVO.setTags(user.getTags());\n                    userVO.setDistance(value); // 设置距离值\n                    return userVO;\n                })\n                .collect(Collectors.toList());\n        System.out.println(userVOList);\n        return ResultUtils.success(userVOList);\n    }\n```\n    \n\n### 改写匹配用户接口\nUserServiceImpl.matchUsers:\n```java\n    /**\n     * 推荐最匹配的用户\n     * @return\n     */\n    @GetMapping(\"/match\")\n    public BaseResponse<List<UserVO>> matchUsers(long num, HttpServletRequest request){\n        if (num <=0 || num > 20) {\n            throw new BusinessException(ErrorCode.PARAMS_ERROR);\n        }\n        User loginUser = userService.getLoginUser(request);\n        return ResultUtils.success(userService.matchUsers(num ,loginUser));\n    }\n```\nUserServiceImpl.matchUsers:\n```java\n    @Override\n    public List<UserVO> matchUsers(long num, User loginUser) {\n        QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n        queryWrapper.isNotNull(\"tags\");\n        queryWrapper.ne(\"id\", loginUser.getId());\n        queryWrapper.select(\"id\",\"tags\");\n        List<User> userList = this.list(queryWrapper);\n\n        String tags = loginUser.getTags();\n        Gson gson = new Gson();\n        List<String> tagList = gson.fromJson(tags, new TypeToken<List<String>>() {\n        }.getType());\n        // 用户列表的下表 => 相似度'\n        List<Pair<User,Long>> list = new ArrayList<>();\n        // 依次计算当前用户和所有用户的相似度\n        for (int i = 0; i <userList.size(); i++) {\n            User user = userList.get(i);\n            String userTags = user.getTags();\n            //无标签的 或当前用户为自己\n            if (StringUtils.isBlank(userTags) || user.getId() == loginUser.getId()){\n                continue;\n            }\n            List<String> userTagList = gson.fromJson(userTags, new TypeToken<List<String>>() {\n            }.getType());\n            //计算分数\n            long distance = AlgorithmUtils.minDistance(tagList, userTagList);\n            list.add(new Pair<>(user,distance));\n        }\n        //按编辑距离有小到大排序\n        List<Pair<User, Long>> topUserPairList = list.stream()\n                .sorted((a, b) -> (int) (a.getValue() - b.getValue()))\n                .limit(num)\n                .collect(Collectors.toList());\n        //有顺序的userID列表\n        List<Long> userListVo = topUserPairList.stream().map(pari -> pari.getKey().getId()).collect(Collectors.toList());\n\n        //根据id查询user完整信息\n        QueryWrapper<User> userQueryWrapper = new QueryWrapper<>();\n        userQueryWrapper.in(\"id\",userListVo);\n        Map<Long, List<User>> userIdUserListMap = this.list(userQueryWrapper).stream()\n                .map(user -> getSafetyUser(user))\n                .collect(Collectors.groupingBy(User::getId));\n\n        List<User> finalUserList = new ArrayList<>();\n        for (Long userId : userListVo){\n            finalUserList.add(userIdUserListMap.get(userId).get(0));\n        }\n\n        String redisUserGeoKey = RedisConstant.USER_GEO_KEY;\n        List<UserVO> finalUserVOList = finalUserList.stream().map(user -> {\n            Distance distance = stringRedisTemplate.opsForGeo().distance(redisUserGeoKey, String.valueOf(loginUser.getId()),\n                    String.valueOf(user.getId()), RedisGeoCommands.DistanceUnit.KILOMETERS);\n\n\n            UserVO userVO = new UserVO();\n            userVO.setId(user.getId());\n            // 这里可以用BeanUtils.copyProperties()，就没必要重复set了\n            userVO.setUsername(user.getUsername());\n            userVO.setUserAccount(user.getUserAccount());\n            userVO.setAvatarUrl(user.getAvatarUrl());\n            userVO.setGender(user.getGender());\n            userVO.setProfile(user.getProfile());\n            userVO.setPhone(user.getPhone());\n            userVO.setEmail(user.getEmail());\n            userVO.setUserStatus(user.getUserStatus());\n            userVO.setCreateTime(user.getCreateTime());\n            userVO.setUpdateTime(user.getUpdateTime());\n            userVO.setUserRole(user.getUserRole());\n            userVO.setPlanetCode(user.getPlanetCode());\n            userVO.setTags(user.getTags());\n            userVO.setDistance(distance.getValue());\n            return userVO;\n        }).collect(Collectors.toList());\n        return finalUserVOList;\n    }\n```\n\n### 添加搜索附近用户接口\nUserController.searchNearby:\n```java\n/**\n     * 搜索附近用户\n     */\n    @GetMapping(\"/searchNearby\")\n    public BaseResponse<List<UserVO>> searchNearby(int radius, HttpServletRequest request) {\n        if (radius <= 0 || radius > 10000) {\n            throw new BusinessException(ErrorCode.PARAMS_ERROR);\n        }\n        User user = userService.getLoginUser(request);\n        User loginUser = userService.getById(user.getId());\n        List<UserVO> userVOList = userService.searchNearby(radius, loginUser);\n        return ResultUtils.success(userVOList);\n    }\n```\nUserServiceImpl.searchNearby:\n```java\n    @Override\n    public List<UserVO> searchNearby(int radius, User loginUser) {\n        String geoKey = RedisConstant.USER_GEO_KEY;\n        String userId = String.valueOf(loginUser.getId());\n        Double longitude = loginUser.getLongitude();\n        Double dimension = loginUser.getDimension();\n        if (longitude == null || dimension == null) {\n            throw new BusinessException(ErrorCode.NULL_ERROR, \"登录用户经纬度参数为空\");\n        }\n        Distance geoRadius = new Distance(radius, RedisGeoCommands.DistanceUnit.KILOMETERS);\n        Circle circle = new Circle(new Point(longitude, dimension), geoRadius);\n        GeoResults<RedisGeoCommands.GeoLocation<String>> results = stringRedisTemplate.opsForGeo()\n                .radius(geoKey, circle);\n        List<Long> userIdList = new ArrayList<>();\n        for (GeoResult<RedisGeoCommands.GeoLocation<String>> result : results) {\n            String id = result.getContent().getName();\n            if (!userId.equals(id)) {\n                userIdList.add(Long.parseLong(id));\n            }\n        }\n        List<UserVO> userVOList = userIdList.stream().map(\n                id -> {\n                    UserVO userVO = new UserVO();\n                    User user = this.getById(id);\n                    BeanUtils.copyProperties(user, userVO);\n                    Distance distance = stringRedisTemplate.opsForGeo().distance(geoKey, userId, String.valueOf(id),\n                            RedisGeoCommands.DistanceUnit.KILOMETERS);\n                    userVO.setDistance(distance.getValue());\n                    return userVO;\n                }\n        ).collect(Collectors.toList());\n        return userVOList;\n    }\n```\n\n## 前端改动\nIndex.vue:\n```js\n<template>\n  <van-search v-model=\"searchText\" placeholder=\"搜索附近用户\" @search=\"onSearch(searchText)\"/>\n  <van-cell center title=\"心动模式\">\n    <template #right-icon>\n      <van-switch v-model=\"isMatchMode\" size=\"24\" />\n    </template>\n  </van-cell>\n  <user-card-list :user-list=\"userList\" :loading=\"loading\"/>\n  <van-empty v-if=\"!userList || userList.length < 1\" description=\"数据为空\" />\n</template>\n\n<script setup lang=\"ts\">\nimport {ref, watchEffect} from \"vue\";\nimport {useRoute} from \"vue-router\";\n\nimport myAxios from \"../plugins/myAxios.ts\";\nimport UserCardList from \"../components/UserCardList.vue\";\nimport {UserType} from \"../models/user\"\nimport {showToast} from \"vant\";\n\nconst route = useRoute();\nconst { tags } = route.query;\nconst searchText = ref('');\nconst userList = ref([]);\nconst isMatchMode = ref<boolean>(false);\nconst loading = ref(true);\n\n/**\n * 加载数据\n */\nconst loadData = async () => {\n  let userListData;\n  loading.value = true;\n  //心动模式\n  if (isMatchMode.value){\n    const num = 10;\n    userListData = await myAxios.get('user/match',{\n      params: {\n        num,\n      },\n    })\n        .then(function (response) {\n          console.log('/user/match succeed',response);\n          return response?.data;\n        })\n        .catch(function (error) {\n          console.log('/user/match error',error);\n        });\n  }else {\n    //普通用户使用分页查询\n    userListData = await myAxios.get('/user/recommend',{\n      params: {\n        pageSize: 8,\n        pageNum: 1,\n      },\n    })\n        .then(function (response) {\n          console.log('/user/recommend succeed', response);\n          return response?.data;\n        })\n        .catch(function (error) {\n          console.log('/user/recommends error',error);\n        });\n\n  }\n  if (userListData){\n    userListData.forEach((user: UserType) =>{\n      if (user.tags){\n        user.tags = JSON.parse(user.tags);\n      }\n    })\n    userList.value = userListData;\n  }\n  loading.value = false;\n}\n\nwatchEffect(() =>{\n  loadData();\n})\n\nconst onSearch = async (searchText) => {\n  let userListData;\n  loading.value = true;\n  const res = await myAxios.get('/user/searchNearby', {\n    params: {\n      radius: searchText\n    }\n  })\n  if (res?.code === 0) {\n    userListData = res?.data;\n    if (userListData){\n      userListData.forEach((user: UserType) =>{\n        if (user.tags){\n          user.tags = JSON.parse(user.tags);\n        }\n      })\n      userList.value = userListData;\n    }\n    loading.value = false;\n  } else {\n    showToast('搜索失败');\n  }\n  loading.value = false;\n};\n\n</script>\n\n<style scoped>\n\n</style>\n```\n\nuser.d.ts:\n```js\n    export type UserType = {\n        id: number;\n        username: string;\n        userAccount: string;\n        avatarUrl?: string;\n        gender:number;\n        profile?: string;\n        phone: string;\n        email: string;\n        userStatus: number;\n        userRole: number;\n        planetCode: string;\n        createTime: Date;\n        tags: string;\n        distance: number;\n    };\n```\n\nUserCardList.vue:\n```js\n  <template>\n  <van-skeleton title avatar :row=\"3\" :loading=\"loading\" v-for=\"user in userList\">\n  <van-card\n      :desc=\"user.profile\"\n      :title=\"`${user.username}(${user.planetCode})`\"\n      :price=\"`${user.distance} km`\"\n      currency=\"\"\n      :thumb=\"user.avatarUrl\"\n  >\n    <template #tags>\n      <van-tag plain type=\"danger\" v-for=\"tag in user.tags\" style=\"margin-right: 8px; margin-top: 8px\">\n        {{ tag }}\n      </van-tag>\n    </template>\n    <template #footer>\n      <van-button size=\"mini\" @click=\"toIntroUser(user)\">联系我</van-button>\n    </template>\n  </van-card>\n  </van-skeleton>\n\n</template>\n\n  <script setup lang=\"ts\">\n  import {UserType} from \"../models/user\";\n  import {useRouter} from \"vue-router\";\n\n  const router = useRouter();\n\n  interface UserCardListProps{\n    loading: boolean\n    userList: UserType[];\n  }\n  withDefaults(defineProps<UserCardListProps>(), {\n    loading: true,\n  })\n\n  const toIntroUser = (user: UserType) => {\n    router.push({\n      path: '/user/intro',\n      query: {\n        userInfoParam: JSON.stringify(user)\n      }\n    });\n  }\n\n  </script>\n\n  <style scoped>\n\n  </style>\n```\n\n\n如果有些的不对的地方，还请各位及时指正。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1608639807578177538/kDkcJ3Id-OIP.jpg",
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 61,
        "thumbNum": 7,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1608639807578177538",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-22 15:00:38",
        "updateTime": "2024-03-12 14:38:39",
        "user": {
          "id": "1608639807578177538",
          "planetCode": "24506",
          "userName": "吃遍全国汉堡\uD83C\uDF54",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/hib5bbuJu0U3DnxEuGVHEiaGEQr55285A2zaluuxopzXxX5xXFwwfbia7uZcbzpQ5HUDIBeZsIq7VMtfdo1icbL86w/132",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [
            "Java"
          ],
          "place": "江苏淮安",
          "birthday": "2003-10-15",
          "school": "",
          "major": "计算机科学与技术",
          "education": "本科",
          "graduationYear": 2025,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "实习",
          "github": null,
          "blog": "https://blog.csdn.net/xyendjsj?spm=1000.2115.3001.5343",
          "score": 0,
          "coin": 0,
          "followeeNum": 3,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-07-04 08:04:09",
          "lastLoginTime": null,
          "createTime": "2022-12-30 09:43:11",
          "updateTime": "2024-03-10 21:50:12"
        },
        "tags": [
          "文章",
          "Java",
          "Redis",
          "伙伴匹配系统"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1760154889335463938",
        "title": " 如何进行 Github 第三方登录详细讲解 （Java 版本）",
        "description": " 如何进行 Github 第三方登录详细讲解 （Java 版本）",
        "content": "# 如何进行 Github 第三方登录详细讲解 （Java 版本）\n\n## 创建一个 Github 应用\n\n1. 点击 Github 的头像\n2. 然后点击设置![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/BpbAXUkY-image.png)\n\n3. 进入设置后，往下滑，点击开发者设置\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/daosmNUV-image.png)\n\n4. 然后点击 Oauth apps\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/S0RwCWae-image.png)\n5. 随后创建一个新的OAuth App\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/5VBiVAxO-image.png)\n6. 可以看到的是期中有几个必填选项，下面我们来一一说明\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/HGRWYic1-image.png)\n\n    1. Application name 这个可以随意填写，就是你的一个应用名字而已\n    2. Homepage URL 填写你自己的前端页面的首页就好了\n    3. Application description 这个就是一个描述，随意填写就好了\n    4. Authorization callback URL 这个就是授权了以后进行身份判断的回调地址，用于自己对第三方信息进行获取，处理，鉴权。比较重要\n    5. 下面是一个填写示例：\n    \n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/Uof3pbiB-image.png)\n7. 全部填写好后我们成功创建了一个 Github 授权应用。\n8. 这里需要我们进行几个关键信息的记录，一个是 client_id 这个不会变，一个是 client_secret （注意，这个只能查看一次请妥善保管），这些信息我们后面需要用。\n\n\n\n\n\n\n## 定义一个跳转按钮，进行 Github 的授权\n\n首先在前端页面中定义一个跳转到 Github 授权页面的链接，示例如下：\n\n```html\n<a href=\"https://github.com/login/oauth/authorize?scope=user:email&client_id=请填写自己的client_id\">Github登录</a>\n```\n\n这里可以自己随意快速的开一个前端应用，然后加一个链接标签，把 href 属性的值如上就可以了，只需要注意的是其中的 client_id 需要换成自己的就行，创建好以后，前后端分离的那么前端几乎就没有事情需要做了。这里主要是前后端分离版本。 \n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/8JS3s54W-image.png)\n\n\n\n\n## 通过授权拿到一个随机的 code \n\n点击上面的 Github 登录以后会出现一个这样的页面\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/P5NZegXh-image.png)\n\n\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/kS3WuVBv-image.png)\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/03ZeCMFZ-image.png)\n\n通过在创建的应用的时候写的回调 URL 进行后端的处理，用户在点击授权以后，页面会重定向进行一个 Get 请求，后端去接收这个请求，并且进行处理就可以了，重定向的时候，会传递一个参数 code ，这个 code 可以用于获取 access_token , 获取到 token 以后用于获取 用户的信息。\n\n接口示例：\n\n```java\npublic class ThirdLoginController {\n    @GetMapping(\"/callback\")\n    public void getCode(String code){\n        System.out.println(code);\n```\n\ndebug 拿值示例\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/AFOIg3OB-image.png)\n\n\n\n这一部分只是为了我能够拿到 code 的值，我们一步一步来，看下面 \uD83D\uDC47\n\n\n\n## 通过 code 进行后端回调处理，拿到access_token\n\n这里我是通过阅读官方文档进行一点一点测试的，官方的文档的语言并不是 Java 这里给出官方文档和我的写法\n\n我的写法(这里发起 Http 请求使用的是 Hutool 工具包)\n\n```java\nMap<String, Object > paramMap = new HashMap<>();\nparamMap.put(\"client_id\",\"填写自己的client_id\");\nparamMap.put(\"client_secret\",\"填写自己的secret\");\nparamMap.put(\"code\",code);\nparamMap.put(\"accept\",\"json\");\nString result = HttpUtil.post(\"https://github.com/login/oauth/access_token\",paramMap);\n```\n\n拿到的结果(类似\uD83D\uDC47)：\n\n```json\naccess_token=gho_lK2Eop11rUH9U7aDTcxUrdORdTPAIS2vVDbh&scope=user%3Aemail&token_type=bearer\n```\n\n\n\n官方参考\n\n```ruby\nget '/callback' do\n  # get temporary GitHub code...\n  session_code = request.env['rack.request.query_hash']['code']\n\n  # ... and POST it back to GitHub\n  result = RestClient.post('https://github.com/login/oauth/access_token',\n                          {:client_id => CLIENT_ID,\n                           :client_secret => CLIENT_SECRET,\n                           :code => session_code},\n                           :accept => :json)\n\n  # extract the token and granted scopes\n  access_token = JSON.parse(result)['access_token']\nend\n```\n\n\n\n## 拿到授权信息以后可以进行获取用户的信息\n\n拿到 token 信息以后，我们要对信息进行处理，从中提取出 access_token 的值，然后就是发起请求获取用户信息了，这里获取用户信息，也是参考官方文档的，后面一直授权不能通过，通过问 AI 解决了问题。\n\n我的示例代码：\n\n```java\n// 处理拿到的信息\nString token = result.split(\"&\")[0].split(\"=\")[1];\n        // 获取用户信息，发起get 请求，拿到用户信息\n        String finalResult = HttpRequest.get(\"https://api.github.com/user\")\n                .header(\"Authorization\",\"token \"+token)\n                .header(\"X-GitHub-Api-Version\", \"2022-11-28\")\n                .execute().body();\n```\n\n> 代码中我出问题的地方在 header 的设置，也就是不知道我获取的 token 怎么传给 github 官方，好像参考的里面说的也不是很明白，后面看了，github 官方关于 授权的文档是要加上两个请求头才能够正常进行请求`Authorization`(这里需要注意的是，token 值得书写，必须是 token后面空格，写access_token的值)   `X-GitHub-Api-Version ` 这个的话就是只需要带上 API 版本的值就好了。\n\n信息结果示例：\n\n```json\n{\n  \"login\": \"xwhking\",\n  \"id\": 97931879,\n  \"node_id\": \"U_kgDOBdZSZw\",\n  \"avatar_url\": \"https://avatars.githubusercontent.com/u/97931879?v=4\",\n  \"gravatar_id\": \"\",\n  \"url\": \"https://api.github.com/users/xwhking\",\n  \"html_url\": \"https://github.com/xwhking\",\n  \"followers_url\": \"https://api.github.com/users/xwhking/followers\",\n  \"following_url\": \"https://api.github.com/users/xwhking/following{/other_user}\",\n  \"gists_url\": \"https://api.github.com/users/xwhking/gists{/gist_id}\",\n  \"starred_url\": \"https://api.github.com/users/xwhking/starred{/owner}{/repo}\",\n  \"subscriptions_url\": \"https://api.github.com/users/xwhking/subscriptions\",\n  \"organizations_url\": \"https://api.github.com/users/xwhking/orgs\",\n  \"repos_url\": \"https://api.github.com/users/xwhking/repos\",\n  \"events_url\": \"https://api.github.com/users/xwhking/events{/privacy}\",\n  \"received_events_url\": \"https://api.github.com/users/xwhking/received_events\",\n  \"type\": \"User\",\n  \"site_admin\": false,\n  \"name\": \"xwhking\",\n  \"company\": null,\n  \"blog\": \"\",\n  \"location\": null,\n  \"email\": null,\n  \"hireable\": null,\n  \"bio\": null,\n  \"twitter_username\": null,\n  \"public_repos\": 8,\n  \"public_gists\": 0,\n  \"followers\": 1,\n  \"following\": 2,\n  \"created_at\": \"2022-01-18T04:06:06Z\",\n  \"updated_at\": \"2024-02-20T02:27:32Z\"\n}\n```\n\n从中我们可以获取一些最为直观的信息，比如 name（github用户名），avatar_url （头像地址），html_url（用户的 github 主页）等。\n\n还可以以同样的方式获取用户的邮箱，只是请求的url 变化一下而且，就是请求 url 变成 `https://api.github.com/user/emails` \n\n请求邮箱结果如下：\n\n```json\n[\n    {\n        \"email\": \"2837468248@qq.com\",\n        \"primary\": true,\n        \"verified\": true,\n        \"visibility\": \"private\"\n    },\n    {\n        \"email\": \"97931879+xwhking@users.noreply.github.com\",\n        \"primary\": false,\n        \"verified\": true,\n        \"visibility\": null\n    }\n]\n```\n\n从中可以获取邮箱信息，通过判断 primary 字段判断是否为私有邮箱。\n\n\n\n参考官方文档：\n\n```ruby\n# fetch user information\nauth_result = JSON.parse(RestClient.get('https://api.github.com/user',\n                                        {:params => {:access_token => access_token}}))\n\n# if the user authorized it, fetch private emails\nif has_user_email_scope\n  auth_result['private_emails'] =\n    JSON.parse(RestClient.get('https://api.github.com/user/emails',\n                              {:params => {:access_token => access_token}}))\nend\n\nerb :basic, :locals => auth_result\n```\n\n\n\n整体的一个后端代码示例：\n\n```java\n@RestController\n@RequestMapping(\"/third_login\")\npublic class ThirdLoginController {\n    @GetMapping(\"/callback\")\n    public void getCode(String code){\n        System.out.println(code);\n        Map<String, Object > paramMap = new HashMap<>();\n        paramMap.put(\"client_id\",\"XXX\");\n        paramMap.put(\"client_secret\",\"XXX\");\n        paramMap.put(\"code\",code);\n        paramMap.put(\"accept\",\"json\");\n        String result = HttpUtil.post(\"https://github.com/login/oauth/access_token\",paramMap);\n        String token = result.split(\"&\")[0].split(\"=\")[1];\n        // 获取用户信息\n        String finalResult = HttpRequest.get(\"https://api.github.com/user\")\n                .header(\"Authorization\",\"token \"+token)\n                .header(\"X-GitHub-Api-Version\", \"2022-11-28\")\n                .execute().body();\n        System.out.println(finalResult);\n\n    }\n}\n```\n\n\n\n\n\n## 拿到的用户信息与数据库进行比对进行登录验证（思路）\n\n我们都拿到 Github 上用户的信息了，那么只需要把拿到的信息放入我们自己的数据库，那么是不是就可以让用户进行登录了呀！\n\n\n\n比如我们可以记录用户的，id，用户名，邮箱，如果用户是第一次登录，就新创建一条记录，如果不是就进行数据库数据的比对进行登录，如果有错误，不让登录就好。没有错误就把页面重定向到对应的前端页面，并且把用户信息返回给前端。这样应该就算是第三方登录了吧！ ",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "componentName": null,
        "viewNum": 51,
        "thumbNum": 2,
        "favourNum": 3,
        "commentNum": 0,
        "priority": 0,
        "userId": "1645799822881509377",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-02-21 12:10:02",
        "updateTime": "2024-03-13 00:03:11",
        "user": {
          "id": "1645799822881509377",
          "planetCode": "14255",
          "userName": "为",
          "userAvatar": null,
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-10-01 21:19:43",
          "lastLoginTime": null,
          "createTime": "2023-04-11 22:43:49",
          "updateTime": "2024-01-30 14:21:10"
        },
        "tags": [
          "文章",
          "Java",
          "GitHub"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "4157",
    "size": "8",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "520"
  },
  "message": "ok"
}